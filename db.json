{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"1299450aa3cf6ff8f985dad989e5f11a60cfa877","modified":1480063833764},{"_id":"source/_posts/Android-Studio：Gradle常用命令.md","hash":"1f9615b3bdc3d2bd17d003a03311960a7d738cc8","modified":1480063833764},{"_id":"source/_posts/Android内存泄露总结.md","hash":"0772d1d542e9fd2834719b20deb3a745b8b20389","modified":1480063833764},{"_id":"source/_posts/Ubuntu下安装配置zsh和oh-my-zsh.md","hash":"5a5e6cb8a00daca7bfd95e5f6cdfc144e122689c","modified":1480063833764},{"_id":"source/_posts/github-hexo-blog.md","hash":"57f28ac2b48b90b703d09e8235bcc3a3e69e3dfc","modified":1480063833764},{"_id":"source/_posts/如何在Android源码中为APK签系统签名？.md","hash":"7510186b56eb4241ef260f86d751584cd78682f2","modified":1480063833764},{"_id":"source/_posts/搬瓦工VPS搭建PPTP-VPN.md","hash":"95ec7a125b1ef8765968d58a03bfb19610ee5f57","modified":1480063833764},{"_id":"source/_posts/android-sticker.md","hash":"47251aa5fac138fe33db5f2644624e854e814a50","modified":1480063833764},{"_id":"public/2016/09/08/android-sticker/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217768},{"_id":"public/2016/07/28/搬瓦工VPS搭建PPTP-VPN/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217769},{"_id":"public/2016/07/20/如何在Android源码中为APK签系统签名？/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217769},{"_id":"public/2016/07/19/Android-Studio：Gradle常用命令/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217769},{"_id":"public/2016/07/15/Ubuntu下安装配置zsh和oh-my-zsh/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217769},{"_id":"public/2016/05/10/Android内存泄露总结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217769},{"_id":"public/2016/03/16/github-hexo-blog/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217769},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217769},{"_id":"public/archives/2016/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217769},{"_id":"public/archives/2016/03/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217769},{"_id":"public/archives/2016/05/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217769},{"_id":"public/archives/2016/07/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217769},{"_id":"public/archives/2016/09/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217770},{"_id":"public/categories/Android/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217770},{"_id":"public/categories/Ubuntu/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217770},{"_id":"public/categories/Android-Studio/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217770},{"_id":"public/categories/Github/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217770},{"_id":"public/categories/VPN/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217771},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217771},{"_id":"public/tags/内存泄露/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217771},{"_id":"public/tags/Zsh/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217771},{"_id":"public/tags/Android-Studio/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217771},{"_id":"public/tags/Hexo/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217771},{"_id":"public/tags/Android签名/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217771},{"_id":"public/tags/贴图/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217771},{"_id":"public/tags/VPN/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1480064217771},{"_id":"public/CNAME","hash":"1299450aa3cf6ff8f985dad989e5f11a60cfa877","modified":1480064217773}],"Category":[{"name":"Android","_id":"civxk0r8300027qh7kn6z9py1"},{"name":"Ubuntu","_id":"civxk0r8a00057qh7pbqjzcmr"},{"name":"Android Studio","_id":"civxk0r8d00097qh7y2u0ojgj"},{"name":"Github","_id":"civxk0r8j000g7qh7k1fwngxx"},{"name":"VPN","_id":"civxk0r8w000p7qh721q4vmfd"}],"Data":[],"Page":[],"Post":[{"title":"Android内存泄露总结","date":"2016-05-10T00:54:32.000Z","_content":"\n#### 前言\n　　不少人认为JAVA程序，因为有垃圾回收机制，应该没有内存泄露。\n其实如果我们一个程序中，已经不再使用某个对象，但是因为仍然有引用指向它，垃圾回收器就无法回收它，当然该对象占用的内存就无法被使用，这就造成了内存泄露。如果我们的java运行很久,而这种内存泄露不断的发生，最后就没内存可用了。当然java的，内存泄漏和C/C++是不一样的。如果java程序完全结束后，它所有的对象就都不可达了，系统就可以对他们进行垃圾回收，它的内存泄露仅仅限于它本身，而不会影响整个系统的。\n　　Android的一个应用程序的内存泄露对别的应用程序影响不大。为了能够使得Android应用程序安全且快速的运行，Android的每个应用程序都会使用一个专有的Dalvik虚拟机实例来运行，它是由Zygote服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。Android为不同类型的进程分配了不同的内存使用上限，如果程序在运行过程中出现了内存泄漏的而造成应用进程使用的内存超过了这个上限，则会被系统视为内存泄漏，从而被kill掉，这使得仅仅自己的进程被kill掉，而不会影响其他进程（如果是system_process等系统进程出问题的话，则会引起系统重启）。\n## 一.内存泄漏常见原因\n* 1.查询数据库没有关闭游标\n* 2.构造 Adapter时，没有使用缓存的convertView\n* 3.Bitmap对象不在使用时调用recycle()释放内存\n* 4.释放对象的引用\n\n## 二.内存泄漏检测方法\n检测工具：\n* 1.Android Studio\n* 2.adb命令\n```\nadb shell dumpsys meminfo 包名\nadb shell dumpsys meminfo -oom 查看当前手机所有进程的内存消耗情况\nadb shell top|grep 包名\n```\n\n测试方法：\n* 1.手动随机测试或指定路径压力测试    \n* 2.利用第三方工具进行制定路径压力测试：按键精灵  \n* 3.monkey测试：adb shell monkey -p com.fineos.camera -v 500  （发送500条伪随机事件）\n\n以Android Studio为例：  \n1.打开应用，不做任何操作时的内存占用  \n2.操作一段时间后，内存占用不断上升  \n3.停止操作，静置一段时间，内存仍未被释放  \n4.手动调用一次GC后，点击dump java heap按钮  \n5.dump成功后会自动打开hprof文件,这个文件会保存在项目根目录下的captures文件夹中，由于Android studio自带的界面查找内存泄漏不是很智能，所以建议使用第三方工具MAT，由于MAT不识别此文件，需右键Export to standard .hprof，然后用MAT打开导出的hprof(File->Open heap dump)\n\n## 三.内存分析工具 MAT\n　　如果使用检测工具确实发现了我们的程序中存在内存泄漏，那又如何定位到具体出现问题的代码片段，最终找到问题所在呢？如果从头到尾的分析代码逻辑，那肯定会把人逼疯，特别是在维护别人写的代码的时候。这里介绍一个极好的内存分析工具 -- Memory Analyzer Tool(MAT) 。  \n　　MAT 是一个 Eclipse 插件，同时也有单独的RCP 客户端。官方下载地址、 MAT 介绍和详细的使用教程请参见：www.eclipse.org/mat，在此不进行说明了。另外在 MAT 安装后的帮助文档里也有完备的使用教程。在此仅举例说明其使用方法。我自己使用的是 MAT 的 eclipse 插件，使用插件要比RCP 稍微方便一些。  \n\n使用MAT 进行内存分析需要几个步骤，包括：生成 .hprof 文件、打开MAT 并导入.hprof文件、使用 MAT 的视图工具分析内存。  \n(a) 生成.hprof文件  \n(b) 使用 MAT导入.hprof文件  \n* 1 如果是 eclipse 自动生成的.hprof 文件，可以使用 MAT 插件直接打开（可能是比较新的 ADT才支持）；\n* 2 如果eclipse 自动生成的 .hprof 文件不能被MAT 直接打开， 或者是使用 android.os.Debug.dumpHprofData()方法手动生成的.hprof 文件，则需要将 .hprof 文件进行转换，转换的方法：\n例如我将 .hprof 文件拷贝到PC 上的/ANDROID_SDK/tools 目录下，并输入命令 hprofconv xxx.hprof yyy.hprof，其中xxx.hprof 为原始文件， yyy.hprof 为转换过后的文件。转换过后的文件自动放在 /ANDROID_SDK/tools 目录下。OK ，到此为止， .hprof 文件处理完毕，可以用来分析内存泄露情况了。\n* 3 在Eclipse 中点击Windows->Open Perspective->Other->Memory Analyzer，或者打Memory Analyzer Tool 的RCP。在 MAT 中点击 File->Open File，浏览并导入刚刚转换而得到的 .hprof文件。  \n\n(c) 使用 MAT的视图工具分析内存\n导入.hprof 文件以后， MAT 会自动解析并生成报告，点击 Dominator Tree，并按Package 分组，选择自己所定义的 Package 类点右键，在弹出菜单中选择 List objects->With incoming\nreferences。这时会列出所有可疑类，右键点击某一项，并选择 Path to GC Roots -> exclude weak/soft references，会进一步筛选出跟程序相关的所有有内存泄露的类。据此，可以追踪到代码中的某一个产生泄露的类。  \n\n具体的分析方法在此不做说明了，因为在 MAT 的官方网站和客户端的帮助文档中有十分详尽的介绍。\n了解MAT 中各个视图的作用很重要，例如 www.eclipse.org/mat/about/screenshots.php 中介绍的。\n总之使用 MAT 分析内存查找内存泄漏的根本思路，就是找到哪个类的对象的引用没有被释放，找到没有被释放的原因，也就可以很容易定位代码中的哪些片段的逻辑有问题了。\n\n## 四.第三方开源库LeakCanary\nLeakCanary是一个开源的检测内存泄露的java库。\n如何集成LeakCanary?  \nIn your build.gradle:\n```\ndependencies {\n  debugCompile 'com.squareup.leakcanary:leakcanary-android:1.4-beta2'\n  releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.4-beta2'\n  testCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.4-beta2'\n}\n```\n\nIn your Application class:\n```\npublic class ExampleApplication extends Application {\n\n  @Override public void onCreate() {\n  super.onCreate();\n  LeakCanary.install(this);\n  }\n}\n```\n\n加入上述代码后，在你的debug版本中如果Activity有内存泄漏，通知栏会自动弹出内存泄漏通知。\n\n更详细的使用教程可以去Github搜LeakCanary：https://github.com/square/leakcanary/wiki/FAQ\n\n## 五.内存泄漏总结\n通过对比MAT和LeakCanary发现，LeakCanary可以很方便的检测出内存泄露的路径，尤其是Context的泄漏，但是对于某些自定义的类或对象，需手动监听，项目初期集成LeakCanary会避免很多内存泄露的情形；\n而MAT则主要列出可疑的类及对象，不能精确定位，需对项目代码熟悉才行。\n\n[阅读原文](http://ckj375.github.io/2016/05/10/Android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%80%BB%E7%BB%93/)\n","source":"_posts/Android内存泄露总结.md","raw":"---\ntitle: Android内存泄露总结\ndate: 2016-05-10 08:54:32\ntags: 内存泄露\ncategories: Android\n---\n\n#### 前言\n　　不少人认为JAVA程序，因为有垃圾回收机制，应该没有内存泄露。\n其实如果我们一个程序中，已经不再使用某个对象，但是因为仍然有引用指向它，垃圾回收器就无法回收它，当然该对象占用的内存就无法被使用，这就造成了内存泄露。如果我们的java运行很久,而这种内存泄露不断的发生，最后就没内存可用了。当然java的，内存泄漏和C/C++是不一样的。如果java程序完全结束后，它所有的对象就都不可达了，系统就可以对他们进行垃圾回收，它的内存泄露仅仅限于它本身，而不会影响整个系统的。\n　　Android的一个应用程序的内存泄露对别的应用程序影响不大。为了能够使得Android应用程序安全且快速的运行，Android的每个应用程序都会使用一个专有的Dalvik虚拟机实例来运行，它是由Zygote服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。Android为不同类型的进程分配了不同的内存使用上限，如果程序在运行过程中出现了内存泄漏的而造成应用进程使用的内存超过了这个上限，则会被系统视为内存泄漏，从而被kill掉，这使得仅仅自己的进程被kill掉，而不会影响其他进程（如果是system_process等系统进程出问题的话，则会引起系统重启）。\n## 一.内存泄漏常见原因\n* 1.查询数据库没有关闭游标\n* 2.构造 Adapter时，没有使用缓存的convertView\n* 3.Bitmap对象不在使用时调用recycle()释放内存\n* 4.释放对象的引用\n\n## 二.内存泄漏检测方法\n检测工具：\n* 1.Android Studio\n* 2.adb命令\n```\nadb shell dumpsys meminfo 包名\nadb shell dumpsys meminfo -oom 查看当前手机所有进程的内存消耗情况\nadb shell top|grep 包名\n```\n\n测试方法：\n* 1.手动随机测试或指定路径压力测试    \n* 2.利用第三方工具进行制定路径压力测试：按键精灵  \n* 3.monkey测试：adb shell monkey -p com.fineos.camera -v 500  （发送500条伪随机事件）\n\n以Android Studio为例：  \n1.打开应用，不做任何操作时的内存占用  \n2.操作一段时间后，内存占用不断上升  \n3.停止操作，静置一段时间，内存仍未被释放  \n4.手动调用一次GC后，点击dump java heap按钮  \n5.dump成功后会自动打开hprof文件,这个文件会保存在项目根目录下的captures文件夹中，由于Android studio自带的界面查找内存泄漏不是很智能，所以建议使用第三方工具MAT，由于MAT不识别此文件，需右键Export to standard .hprof，然后用MAT打开导出的hprof(File->Open heap dump)\n\n## 三.内存分析工具 MAT\n　　如果使用检测工具确实发现了我们的程序中存在内存泄漏，那又如何定位到具体出现问题的代码片段，最终找到问题所在呢？如果从头到尾的分析代码逻辑，那肯定会把人逼疯，特别是在维护别人写的代码的时候。这里介绍一个极好的内存分析工具 -- Memory Analyzer Tool(MAT) 。  \n　　MAT 是一个 Eclipse 插件，同时也有单独的RCP 客户端。官方下载地址、 MAT 介绍和详细的使用教程请参见：www.eclipse.org/mat，在此不进行说明了。另外在 MAT 安装后的帮助文档里也有完备的使用教程。在此仅举例说明其使用方法。我自己使用的是 MAT 的 eclipse 插件，使用插件要比RCP 稍微方便一些。  \n\n使用MAT 进行内存分析需要几个步骤，包括：生成 .hprof 文件、打开MAT 并导入.hprof文件、使用 MAT 的视图工具分析内存。  \n(a) 生成.hprof文件  \n(b) 使用 MAT导入.hprof文件  \n* 1 如果是 eclipse 自动生成的.hprof 文件，可以使用 MAT 插件直接打开（可能是比较新的 ADT才支持）；\n* 2 如果eclipse 自动生成的 .hprof 文件不能被MAT 直接打开， 或者是使用 android.os.Debug.dumpHprofData()方法手动生成的.hprof 文件，则需要将 .hprof 文件进行转换，转换的方法：\n例如我将 .hprof 文件拷贝到PC 上的/ANDROID_SDK/tools 目录下，并输入命令 hprofconv xxx.hprof yyy.hprof，其中xxx.hprof 为原始文件， yyy.hprof 为转换过后的文件。转换过后的文件自动放在 /ANDROID_SDK/tools 目录下。OK ，到此为止， .hprof 文件处理完毕，可以用来分析内存泄露情况了。\n* 3 在Eclipse 中点击Windows->Open Perspective->Other->Memory Analyzer，或者打Memory Analyzer Tool 的RCP。在 MAT 中点击 File->Open File，浏览并导入刚刚转换而得到的 .hprof文件。  \n\n(c) 使用 MAT的视图工具分析内存\n导入.hprof 文件以后， MAT 会自动解析并生成报告，点击 Dominator Tree，并按Package 分组，选择自己所定义的 Package 类点右键，在弹出菜单中选择 List objects->With incoming\nreferences。这时会列出所有可疑类，右键点击某一项，并选择 Path to GC Roots -> exclude weak/soft references，会进一步筛选出跟程序相关的所有有内存泄露的类。据此，可以追踪到代码中的某一个产生泄露的类。  \n\n具体的分析方法在此不做说明了，因为在 MAT 的官方网站和客户端的帮助文档中有十分详尽的介绍。\n了解MAT 中各个视图的作用很重要，例如 www.eclipse.org/mat/about/screenshots.php 中介绍的。\n总之使用 MAT 分析内存查找内存泄漏的根本思路，就是找到哪个类的对象的引用没有被释放，找到没有被释放的原因，也就可以很容易定位代码中的哪些片段的逻辑有问题了。\n\n## 四.第三方开源库LeakCanary\nLeakCanary是一个开源的检测内存泄露的java库。\n如何集成LeakCanary?  \nIn your build.gradle:\n```\ndependencies {\n  debugCompile 'com.squareup.leakcanary:leakcanary-android:1.4-beta2'\n  releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.4-beta2'\n  testCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.4-beta2'\n}\n```\n\nIn your Application class:\n```\npublic class ExampleApplication extends Application {\n\n  @Override public void onCreate() {\n  super.onCreate();\n  LeakCanary.install(this);\n  }\n}\n```\n\n加入上述代码后，在你的debug版本中如果Activity有内存泄漏，通知栏会自动弹出内存泄漏通知。\n\n更详细的使用教程可以去Github搜LeakCanary：https://github.com/square/leakcanary/wiki/FAQ\n\n## 五.内存泄漏总结\n通过对比MAT和LeakCanary发现，LeakCanary可以很方便的检测出内存泄露的路径，尤其是Context的泄漏，但是对于某些自定义的类或对象，需手动监听，项目初期集成LeakCanary会避免很多内存泄露的情形；\n而MAT则主要列出可疑的类及对象，不能精确定位，需对项目代码熟悉才行。\n\n[阅读原文](http://ckj375.github.io/2016/05/10/Android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%80%BB%E7%BB%93/)\n","slug":"Android内存泄露总结","published":1,"updated":"2016-11-25T08:50:33.764Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civxk0r7w00007qh77iossje2","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>　　不少人认为JAVA程序，因为有垃圾回收机制，应该没有内存泄露。<br>其实如果我们一个程序中，已经不再使用某个对象，但是因为仍然有引用指向它，垃圾回收器就无法回收它，当然该对象占用的内存就无法被使用，这就造成了内存泄露。如果我们的java运行很久,而这种内存泄露不断的发生，最后就没内存可用了。当然java的，内存泄漏和C/C++是不一样的。如果java程序完全结束后，它所有的对象就都不可达了，系统就可以对他们进行垃圾回收，它的内存泄露仅仅限于它本身，而不会影响整个系统的。<br>　　Android的一个应用程序的内存泄露对别的应用程序影响不大。为了能够使得Android应用程序安全且快速的运行，Android的每个应用程序都会使用一个专有的Dalvik虚拟机实例来运行，它是由Zygote服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。Android为不同类型的进程分配了不同的内存使用上限，如果程序在运行过程中出现了内存泄漏的而造成应用进程使用的内存超过了这个上限，则会被系统视为内存泄漏，从而被kill掉，这使得仅仅自己的进程被kill掉，而不会影响其他进程（如果是system_process等系统进程出问题的话，则会引起系统重启）。</p>\n<h2 id=\"一-内存泄漏常见原因\"><a href=\"#一-内存泄漏常见原因\" class=\"headerlink\" title=\"一.内存泄漏常见原因\"></a>一.内存泄漏常见原因</h2><ul>\n<li>1.查询数据库没有关闭游标</li>\n<li>2.构造 Adapter时，没有使用缓存的convertView</li>\n<li>3.Bitmap对象不在使用时调用recycle()释放内存</li>\n<li>4.释放对象的引用</li>\n</ul>\n<h2 id=\"二-内存泄漏检测方法\"><a href=\"#二-内存泄漏检测方法\" class=\"headerlink\" title=\"二.内存泄漏检测方法\"></a>二.内存泄漏检测方法</h2><p>检测工具：</p>\n<ul>\n<li>1.Android Studio</li>\n<li>2.adb命令<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">adb shell dumpsys meminfo 包名</div><div class=\"line\">adb shell dumpsys meminfo -oom 查看当前手机所有进程的内存消耗情况</div><div class=\"line\">adb shell top|grep 包名</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>测试方法：</p>\n<ul>\n<li>1.手动随机测试或指定路径压力测试    </li>\n<li>2.利用第三方工具进行制定路径压力测试：按键精灵  </li>\n<li>3.monkey测试：adb shell monkey -p com.fineos.camera -v 500  （发送500条伪随机事件）</li>\n</ul>\n<p>以Android Studio为例：<br>1.打开应用，不做任何操作时的内存占用<br>2.操作一段时间后，内存占用不断上升<br>3.停止操作，静置一段时间，内存仍未被释放<br>4.手动调用一次GC后，点击dump java heap按钮<br>5.dump成功后会自动打开hprof文件,这个文件会保存在项目根目录下的captures文件夹中，由于Android studio自带的界面查找内存泄漏不是很智能，所以建议使用第三方工具MAT，由于MAT不识别此文件，需右键Export to standard .hprof，然后用MAT打开导出的hprof(File-&gt;Open heap dump)</p>\n<h2 id=\"三-内存分析工具-MAT\"><a href=\"#三-内存分析工具-MAT\" class=\"headerlink\" title=\"三.内存分析工具 MAT\"></a>三.内存分析工具 MAT</h2><p>　　如果使用检测工具确实发现了我们的程序中存在内存泄漏，那又如何定位到具体出现问题的代码片段，最终找到问题所在呢？如果从头到尾的分析代码逻辑，那肯定会把人逼疯，特别是在维护别人写的代码的时候。这里介绍一个极好的内存分析工具 – Memory Analyzer Tool(MAT) 。<br>　　MAT 是一个 Eclipse 插件，同时也有单独的RCP 客户端。官方下载地址、 MAT 介绍和详细的使用教程请参见：www.eclipse.org/mat，在此不进行说明了。另外在 MAT 安装后的帮助文档里也有完备的使用教程。在此仅举例说明其使用方法。我自己使用的是 MAT 的 eclipse 插件，使用插件要比RCP 稍微方便一些。  </p>\n<p>使用MAT 进行内存分析需要几个步骤，包括：生成 .hprof 文件、打开MAT 并导入.hprof文件、使用 MAT 的视图工具分析内存。<br>(a) 生成.hprof文件<br>(b) 使用 MAT导入.hprof文件  </p>\n<ul>\n<li>1 如果是 eclipse 自动生成的.hprof 文件，可以使用 MAT 插件直接打开（可能是比较新的 ADT才支持）；</li>\n<li>2 如果eclipse 自动生成的 .hprof 文件不能被MAT 直接打开， 或者是使用 android.os.Debug.dumpHprofData()方法手动生成的.hprof 文件，则需要将 .hprof 文件进行转换，转换的方法：<br>例如我将 .hprof 文件拷贝到PC 上的/ANDROID_SDK/tools 目录下，并输入命令 hprofconv xxx.hprof yyy.hprof，其中xxx.hprof 为原始文件， yyy.hprof 为转换过后的文件。转换过后的文件自动放在 /ANDROID_SDK/tools 目录下。OK ，到此为止， .hprof 文件处理完毕，可以用来分析内存泄露情况了。</li>\n<li>3 在Eclipse 中点击Windows-&gt;Open Perspective-&gt;Other-&gt;Memory Analyzer，或者打Memory Analyzer Tool 的RCP。在 MAT 中点击 File-&gt;Open File，浏览并导入刚刚转换而得到的 .hprof文件。  </li>\n</ul>\n<p>(c) 使用 MAT的视图工具分析内存<br>导入.hprof 文件以后， MAT 会自动解析并生成报告，点击 Dominator Tree，并按Package 分组，选择自己所定义的 Package 类点右键，在弹出菜单中选择 List objects-&gt;With incoming<br>references。这时会列出所有可疑类，右键点击某一项，并选择 Path to GC Roots -&gt; exclude weak/soft references，会进一步筛选出跟程序相关的所有有内存泄露的类。据此，可以追踪到代码中的某一个产生泄露的类。  </p>\n<p>具体的分析方法在此不做说明了，因为在 MAT 的官方网站和客户端的帮助文档中有十分详尽的介绍。<br>了解MAT 中各个视图的作用很重要，例如 www.eclipse.org/mat/about/screenshots.php 中介绍的。<br>总之使用 MAT 分析内存查找内存泄漏的根本思路，就是找到哪个类的对象的引用没有被释放，找到没有被释放的原因，也就可以很容易定位代码中的哪些片段的逻辑有问题了。</p>\n<h2 id=\"四-第三方开源库LeakCanary\"><a href=\"#四-第三方开源库LeakCanary\" class=\"headerlink\" title=\"四.第三方开源库LeakCanary\"></a>四.第三方开源库LeakCanary</h2><p>LeakCanary是一个开源的检测内存泄露的java库。<br>如何集成LeakCanary?<br>In your build.gradle:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">  debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.4-beta2&apos;</div><div class=\"line\">  releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.4-beta2&apos;</div><div class=\"line\">  testCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.4-beta2&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>In your Application class:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class ExampleApplication extends Application &#123;</div><div class=\"line\"></div><div class=\"line\">  @Override public void onCreate() &#123;</div><div class=\"line\">  super.onCreate();</div><div class=\"line\">  LeakCanary.install(this);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>加入上述代码后，在你的debug版本中如果Activity有内存泄漏，通知栏会自动弹出内存泄漏通知。</p>\n<p>更详细的使用教程可以去Github搜LeakCanary：<a href=\"https://github.com/square/leakcanary/wiki/FAQ\" target=\"_blank\" rel=\"external\">https://github.com/square/leakcanary/wiki/FAQ</a></p>\n<h2 id=\"五-内存泄漏总结\"><a href=\"#五-内存泄漏总结\" class=\"headerlink\" title=\"五.内存泄漏总结\"></a>五.内存泄漏总结</h2><p>通过对比MAT和LeakCanary发现，LeakCanary可以很方便的检测出内存泄露的路径，尤其是Context的泄漏，但是对于某些自定义的类或对象，需手动监听，项目初期集成LeakCanary会避免很多内存泄露的情形；<br>而MAT则主要列出可疑的类及对象，不能精确定位，需对项目代码熟悉才行。</p>\n<p><a href=\"http://ckj375.github.io/2016/05/10/Android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%80%BB%E7%BB%93/\" target=\"_blank\" rel=\"external\">阅读原文</a></p>\n","excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>　　不少人认为JAVA程序，因为有垃圾回收机制，应该没有内存泄露。<br>其实如果我们一个程序中，已经不再使用某个对象，但是因为仍然有引用指向它，垃圾回收器就无法回收它，当然该对象占用的内存就无法被使用，这就造成了内存泄露。如果我们的java运行很久,而这种内存泄露不断的发生，最后就没内存可用了。当然java的，内存泄漏和C/C++是不一样的。如果java程序完全结束后，它所有的对象就都不可达了，系统就可以对他们进行垃圾回收，它的内存泄露仅仅限于它本身，而不会影响整个系统的。<br>　　Android的一个应用程序的内存泄露对别的应用程序影响不大。为了能够使得Android应用程序安全且快速的运行，Android的每个应用程序都会使用一个专有的Dalvik虚拟机实例来运行，它是由Zygote服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。Android为不同类型的进程分配了不同的内存使用上限，如果程序在运行过程中出现了内存泄漏的而造成应用进程使用的内存超过了这个上限，则会被系统视为内存泄漏，从而被kill掉，这使得仅仅自己的进程被kill掉，而不会影响其他进程（如果是system_process等系统进程出问题的话，则会引起系统重启）。</p>\n<h2 id=\"一-内存泄漏常见原因\"><a href=\"#一-内存泄漏常见原因\" class=\"headerlink\" title=\"一.内存泄漏常见原因\"></a>一.内存泄漏常见原因</h2><ul>\n<li>1.查询数据库没有关闭游标</li>\n<li>2.构造 Adapter时，没有使用缓存的convertView</li>\n<li>3.Bitmap对象不在使用时调用recycle()释放内存</li>\n<li>4.释放对象的引用</li>\n</ul>\n<h2 id=\"二-内存泄漏检测方法\"><a href=\"#二-内存泄漏检测方法\" class=\"headerlink\" title=\"二.内存泄漏检测方法\"></a>二.内存泄漏检测方法</h2><p>检测工具：</p>\n<ul>\n<li>1.Android Studio</li>\n<li>2.adb命令<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">adb shell dumpsys meminfo 包名</div><div class=\"line\">adb shell dumpsys meminfo -oom 查看当前手机所有进程的内存消耗情况</div><div class=\"line\">adb shell top|grep 包名</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>测试方法：</p>\n<ul>\n<li>1.手动随机测试或指定路径压力测试    </li>\n<li>2.利用第三方工具进行制定路径压力测试：按键精灵  </li>\n<li>3.monkey测试：adb shell monkey -p com.fineos.camera -v 500  （发送500条伪随机事件）</li>\n</ul>\n<p>以Android Studio为例：<br>1.打开应用，不做任何操作时的内存占用<br>2.操作一段时间后，内存占用不断上升<br>3.停止操作，静置一段时间，内存仍未被释放<br>4.手动调用一次GC后，点击dump java heap按钮<br>5.dump成功后会自动打开hprof文件,这个文件会保存在项目根目录下的captures文件夹中，由于Android studio自带的界面查找内存泄漏不是很智能，所以建议使用第三方工具MAT，由于MAT不识别此文件，需右键Export to standard .hprof，然后用MAT打开导出的hprof(File-&gt;Open heap dump)</p>\n<h2 id=\"三-内存分析工具-MAT\"><a href=\"#三-内存分析工具-MAT\" class=\"headerlink\" title=\"三.内存分析工具 MAT\"></a>三.内存分析工具 MAT</h2><p>　　如果使用检测工具确实发现了我们的程序中存在内存泄漏，那又如何定位到具体出现问题的代码片段，最终找到问题所在呢？如果从头到尾的分析代码逻辑，那肯定会把人逼疯，特别是在维护别人写的代码的时候。这里介绍一个极好的内存分析工具 – Memory Analyzer Tool(MAT) 。<br>　　MAT 是一个 Eclipse 插件，同时也有单独的RCP 客户端。官方下载地址、 MAT 介绍和详细的使用教程请参见：www.eclipse.org/mat，在此不进行说明了。另外在 MAT 安装后的帮助文档里也有完备的使用教程。在此仅举例说明其使用方法。我自己使用的是 MAT 的 eclipse 插件，使用插件要比RCP 稍微方便一些。  </p>\n<p>使用MAT 进行内存分析需要几个步骤，包括：生成 .hprof 文件、打开MAT 并导入.hprof文件、使用 MAT 的视图工具分析内存。<br>(a) 生成.hprof文件<br>(b) 使用 MAT导入.hprof文件  </p>\n<ul>\n<li>1 如果是 eclipse 自动生成的.hprof 文件，可以使用 MAT 插件直接打开（可能是比较新的 ADT才支持）；</li>\n<li>2 如果eclipse 自动生成的 .hprof 文件不能被MAT 直接打开， 或者是使用 android.os.Debug.dumpHprofData()方法手动生成的.hprof 文件，则需要将 .hprof 文件进行转换，转换的方法：<br>例如我将 .hprof 文件拷贝到PC 上的/ANDROID_SDK/tools 目录下，并输入命令 hprofconv xxx.hprof yyy.hprof，其中xxx.hprof 为原始文件， yyy.hprof 为转换过后的文件。转换过后的文件自动放在 /ANDROID_SDK/tools 目录下。OK ，到此为止， .hprof 文件处理完毕，可以用来分析内存泄露情况了。</li>\n<li>3 在Eclipse 中点击Windows-&gt;Open Perspective-&gt;Other-&gt;Memory Analyzer，或者打Memory Analyzer Tool 的RCP。在 MAT 中点击 File-&gt;Open File，浏览并导入刚刚转换而得到的 .hprof文件。  </li>\n</ul>\n<p>(c) 使用 MAT的视图工具分析内存<br>导入.hprof 文件以后， MAT 会自动解析并生成报告，点击 Dominator Tree，并按Package 分组，选择自己所定义的 Package 类点右键，在弹出菜单中选择 List objects-&gt;With incoming<br>references。这时会列出所有可疑类，右键点击某一项，并选择 Path to GC Roots -&gt; exclude weak/soft references，会进一步筛选出跟程序相关的所有有内存泄露的类。据此，可以追踪到代码中的某一个产生泄露的类。  </p>\n<p>具体的分析方法在此不做说明了，因为在 MAT 的官方网站和客户端的帮助文档中有十分详尽的介绍。<br>了解MAT 中各个视图的作用很重要，例如 www.eclipse.org/mat/about/screenshots.php 中介绍的。<br>总之使用 MAT 分析内存查找内存泄漏的根本思路，就是找到哪个类的对象的引用没有被释放，找到没有被释放的原因，也就可以很容易定位代码中的哪些片段的逻辑有问题了。</p>\n<h2 id=\"四-第三方开源库LeakCanary\"><a href=\"#四-第三方开源库LeakCanary\" class=\"headerlink\" title=\"四.第三方开源库LeakCanary\"></a>四.第三方开源库LeakCanary</h2><p>LeakCanary是一个开源的检测内存泄露的java库。<br>如何集成LeakCanary?<br>In your build.gradle:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">dependencies &#123;</div><div class=\"line\">  debugCompile &apos;com.squareup.leakcanary:leakcanary-android:1.4-beta2&apos;</div><div class=\"line\">  releaseCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.4-beta2&apos;</div><div class=\"line\">  testCompile &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.4-beta2&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>In your Application class:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class ExampleApplication extends Application &#123;</div><div class=\"line\"></div><div class=\"line\">  @Override public void onCreate() &#123;</div><div class=\"line\">  super.onCreate();</div><div class=\"line\">  LeakCanary.install(this);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>加入上述代码后，在你的debug版本中如果Activity有内存泄漏，通知栏会自动弹出内存泄漏通知。</p>\n<p>更详细的使用教程可以去Github搜LeakCanary：<a href=\"https://github.com/square/leakcanary/wiki/FAQ\">https://github.com/square/leakcanary/wiki/FAQ</a></p>\n<h2 id=\"五-内存泄漏总结\"><a href=\"#五-内存泄漏总结\" class=\"headerlink\" title=\"五.内存泄漏总结\"></a>五.内存泄漏总结</h2><p>通过对比MAT和LeakCanary发现，LeakCanary可以很方便的检测出内存泄露的路径，尤其是Context的泄漏，但是对于某些自定义的类或对象，需手动监听，项目初期集成LeakCanary会避免很多内存泄露的情形；<br>而MAT则主要列出可疑的类及对象，不能精确定位，需对项目代码熟悉才行。</p>\n<p><a href=\"http://ckj375.github.io/2016/05/10/Android%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%80%BB%E7%BB%93/\">阅读原文</a></p>\n"},{"title":"Ubuntu下安装配置zsh和oh my zsh","date":"2016-07-15T09:09:36.000Z","_content":"\nzsh优势：自动补全功能强大和很高的可配置性\n------\n1. 查看当前系统装了哪些shell\n   cat /etc/shells\n2. 当前正在运行的是哪个版本的shell\n   echo $SHELL\n3. 安装zsh\n   sudo apt-get zsh\n4. 切换zsh\n   chsh -s /bin/bash(非实时，需重启)\n5. 安装oh my zsh\n   wget --no-check-certificate https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh\n6. 设置zsh的参数\n   安装完zsh后，在home目录下会有一个名为.zshrc的隐藏文件，可以根据个人习惯配置zsh的参数\n   oh my zsh 在安装时已经自动读取当前的环境变量并进行了设置，你可以继续追加其他环境变量\n\n   oh my zsh各式各样的主题预览：https://github.com/robbyrussell/oh-my-zsh/wiki/themes\n\n   [阅读原文](http://ckj375.github.io/2016/07/15/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEzsh%E5%92%8Coh-my-zsh/)\n","source":"_posts/Ubuntu下安装配置zsh和oh-my-zsh.md","raw":"---\ntitle: Ubuntu下安装配置zsh和oh my zsh\ndate: 2016-07-15 17:09:36\ntags: Zsh\ncategories: Ubuntu\n---\n\nzsh优势：自动补全功能强大和很高的可配置性\n------\n1. 查看当前系统装了哪些shell\n   cat /etc/shells\n2. 当前正在运行的是哪个版本的shell\n   echo $SHELL\n3. 安装zsh\n   sudo apt-get zsh\n4. 切换zsh\n   chsh -s /bin/bash(非实时，需重启)\n5. 安装oh my zsh\n   wget --no-check-certificate https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh\n6. 设置zsh的参数\n   安装完zsh后，在home目录下会有一个名为.zshrc的隐藏文件，可以根据个人习惯配置zsh的参数\n   oh my zsh 在安装时已经自动读取当前的环境变量并进行了设置，你可以继续追加其他环境变量\n\n   oh my zsh各式各样的主题预览：https://github.com/robbyrussell/oh-my-zsh/wiki/themes\n\n   [阅读原文](http://ckj375.github.io/2016/07/15/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEzsh%E5%92%8Coh-my-zsh/)\n","slug":"Ubuntu下安装配置zsh和oh-my-zsh","published":1,"updated":"2016-11-25T08:50:33.764Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civxk0r8100017qh7vrajhwq5","content":"<h2 id=\"zsh优势：自动补全功能强大和很高的可配置性\"><a href=\"#zsh优势：自动补全功能强大和很高的可配置性\" class=\"headerlink\" title=\"zsh优势：自动补全功能强大和很高的可配置性\"></a>zsh优势：自动补全功能强大和很高的可配置性</h2><ol>\n<li>查看当前系统装了哪些shell<br>cat /etc/shells</li>\n<li>当前正在运行的是哪个版本的shell<br>echo $SHELL</li>\n<li>安装zsh<br>sudo apt-get zsh</li>\n<li>切换zsh<br>chsh -s /bin/bash(非实时，需重启)</li>\n<li>安装oh my zsh<br>wget –no-check-certificate <a href=\"https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh\" target=\"_blank\" rel=\"external\">https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh</a> -O - | sh</li>\n<li><p>设置zsh的参数<br>安装完zsh后，在home目录下会有一个名为.zshrc的隐藏文件，可以根据个人习惯配置zsh的参数<br>oh my zsh 在安装时已经自动读取当前的环境变量并进行了设置，你可以继续追加其他环境变量</p>\n<p>oh my zsh各式各样的主题预览：<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/themes\" target=\"_blank\" rel=\"external\">https://github.com/robbyrussell/oh-my-zsh/wiki/themes</a></p>\n<p><a href=\"http://ckj375.github.io/2016/07/15/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEzsh%E5%92%8Coh-my-zsh/\" target=\"_blank\" rel=\"external\">阅读原文</a></p>\n</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"zsh优势：自动补全功能强大和很高的可配置性\"><a href=\"#zsh优势：自动补全功能强大和很高的可配置性\" class=\"headerlink\" title=\"zsh优势：自动补全功能强大和很高的可配置性\"></a>zsh优势：自动补全功能强大和很高的可配置性</h2><ol>\n<li>查看当前系统装了哪些shell<br>cat /etc/shells</li>\n<li>当前正在运行的是哪个版本的shell<br>echo $SHELL</li>\n<li>安装zsh<br>sudo apt-get zsh</li>\n<li>切换zsh<br>chsh -s /bin/bash(非实时，需重启)</li>\n<li>安装oh my zsh<br>wget –no-check-certificate <a href=\"https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh\">https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh</a> -O - | sh</li>\n<li><p>设置zsh的参数<br>安装完zsh后，在home目录下会有一个名为.zshrc的隐藏文件，可以根据个人习惯配置zsh的参数<br>oh my zsh 在安装时已经自动读取当前的环境变量并进行了设置，你可以继续追加其他环境变量</p>\n<p>oh my zsh各式各样的主题预览：<a href=\"https://github.com/robbyrussell/oh-my-zsh/wiki/themes\">https://github.com/robbyrussell/oh-my-zsh/wiki/themes</a></p>\n<p><a href=\"http://ckj375.github.io/2016/07/15/Ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEzsh%E5%92%8Coh-my-zsh/\">阅读原文</a></p>\n</li>\n</ol>\n"},{"title":"Android Studio：Gradle常用命令","date":"2016-07-19T07:33:51.000Z","_content":"\nAndroid Studio中自带Terminal，可以直接使用gradle命令，不用另开命令窗口，相当方便，下面总结一下常用的命令：\n* 1.查看Gradle版本号\n```\n./gradlew -v\n```\n* 2.清除app目录下的build文件夹\n```\n./gradlew clean\n```\n* 3.检查依赖并编译打包\n```\n./gradlew build\n```\n* 4.编译并打Debug包\n```\n./gradlew assembleDebug\n```\n* 5.编译并打Release包\n```\n./gradlew assembleRelease\n```\n* 6.结合productFlavors可以编译指定Flavor的debug或release版本\n```\n./gradlew assembleFlavor     \n./gradlew assembleFlavorDebug\n./gradlew assembleFlavorRelease\n```\n[阅读原文](http://ckj375.github.io/2016/07/19/Android-Studio%EF%BC%9AGradle%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/)\n","source":"_posts/Android-Studio：Gradle常用命令.md","raw":"---\ntitle: Android Studio：Gradle常用命令\ndate: 2016-07-19 15:33:51\ntags: Android Studio\ncategories: Android Studio\n---\n\nAndroid Studio中自带Terminal，可以直接使用gradle命令，不用另开命令窗口，相当方便，下面总结一下常用的命令：\n* 1.查看Gradle版本号\n```\n./gradlew -v\n```\n* 2.清除app目录下的build文件夹\n```\n./gradlew clean\n```\n* 3.检查依赖并编译打包\n```\n./gradlew build\n```\n* 4.编译并打Debug包\n```\n./gradlew assembleDebug\n```\n* 5.编译并打Release包\n```\n./gradlew assembleRelease\n```\n* 6.结合productFlavors可以编译指定Flavor的debug或release版本\n```\n./gradlew assembleFlavor     \n./gradlew assembleFlavorDebug\n./gradlew assembleFlavorRelease\n```\n[阅读原文](http://ckj375.github.io/2016/07/19/Android-Studio%EF%BC%9AGradle%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/)\n","slug":"Android-Studio：Gradle常用命令","published":1,"updated":"2016-11-25T08:50:33.764Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civxk0r8700047qh7mu1h4myl","content":"<p>Android Studio中自带Terminal，可以直接使用gradle命令，不用另开命令窗口，相当方便，下面总结一下常用的命令：</p>\n<ul>\n<li><p>1.查看Gradle版本号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./gradlew -v</div></pre></td></tr></table></figure>\n</li>\n<li><p>2.清除app目录下的build文件夹</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./gradlew clean</div></pre></td></tr></table></figure>\n</li>\n<li><p>3.检查依赖并编译打包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./gradlew build</div></pre></td></tr></table></figure>\n</li>\n<li><p>4.编译并打Debug包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./gradlew assembleDebug</div></pre></td></tr></table></figure>\n</li>\n<li><p>5.编译并打Release包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./gradlew assembleRelease</div></pre></td></tr></table></figure>\n</li>\n<li><p>6.结合productFlavors可以编译指定Flavor的debug或release版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">./gradlew assembleFlavor     </div><div class=\"line\">./gradlew assembleFlavorDebug</div><div class=\"line\">./gradlew assembleFlavorRelease</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><a href=\"http://ckj375.github.io/2016/07/19/Android-Studio%EF%BC%9AGradle%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/\" target=\"_blank\" rel=\"external\">阅读原文</a></p>\n","excerpt":"","more":"<p>Android Studio中自带Terminal，可以直接使用gradle命令，不用另开命令窗口，相当方便，下面总结一下常用的命令：</p>\n<ul>\n<li><p>1.查看Gradle版本号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./gradlew -v</div></pre></td></tr></table></figure>\n</li>\n<li><p>2.清除app目录下的build文件夹</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./gradlew clean</div></pre></td></tr></table></figure>\n</li>\n<li><p>3.检查依赖并编译打包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./gradlew build</div></pre></td></tr></table></figure>\n</li>\n<li><p>4.编译并打Debug包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./gradlew assembleDebug</div></pre></td></tr></table></figure>\n</li>\n<li><p>5.编译并打Release包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./gradlew assembleRelease</div></pre></td></tr></table></figure>\n</li>\n<li><p>6.结合productFlavors可以编译指定Flavor的debug或release版本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">./gradlew assembleFlavor     </div><div class=\"line\">./gradlew assembleFlavorDebug</div><div class=\"line\">./gradlew assembleFlavorRelease</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><a href=\"http://ckj375.github.io/2016/07/19/Android-Studio%EF%BC%9AGradle%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/\">阅读原文</a></p>\n"},{"title":"Github上搭建Hexo博客","date":"2016-03-16T03:22:55.000Z","_content":"\n1. 安装Git和NodeJs\n------\n此处略过,不会的童鞋找谷哥...\n\n2. 安装hexo\n------\n去github上创建仓库，name.github.io,示例：ckj375.github.io\n创建2个分支：master和hexo，并设置hexo为默认分支，hexo分支用于存放网站原始文件，master分支用于存放生成的静态网页。\n克隆代码仓  \n```\ngit clone https://github.com/ckj375/ckj375.github.io.git\n```\n进入目录，依次执行以下命令\n```\nhexo init  \nnpm install  \nnpm install hexo-deployer-git --save  \nhexo generate  \nhexo server  \n```\n打开本地浏览器按照提示输入url即可访问本地博客了,若提示找不到hexo server这条指令,输入\n```\nnpm install hexo -server --save\n```\n修改_config.yml中的deploy参数（注意冒号后面要加空格）\n```\ndeploy:  \n    type: git  \n    repo: https://github.com/ckj375/ckj375.github.io.git  \n    branch: master\n```\n网站作者和标题：修改站点配置文件_config.yml的author和title字段\n```\nauthor: chenkaijian\ntitle: 皮皮熊的博客\n```\n通过Git将网站原始文件提交至hexo分支：\n```\ngit push origin hexo\nhexo generate 生成网站\nhexo deploy 将网站部署到github的master（前面已经在站点配置文件_config.yml中配置deploy参数）\n```\n\n3. hexo常用命令\n------\n```\nhexo help #查看帮助  \nhexo init #初始化一个目录  \nhexo new \"postName\" #新建文章  \nhexo new page \"pageName\" #新建页面  \nhexo generate #生成网页，可以在 public 目录查看整个网站的文件  \nhexo server #本地预览  \nhexo deploy #部署.deploy目录  \nhexo clean #清除缓存，建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹\n```\n简写  \n```\nhexo n == hexo new  \nhexo g == hexo generate  \nhexo s == hexo server  \nhexo d == hexo deploy  \n```\n\n4. 主题配置\n------\n个人比较喜欢简约风的主题，所以选了Next主题  \n首先去fork一套next主题源码:https://github.com/iissnan/hexo-theme-next  \n进入仓库根目录克隆最新版本的next主题：\n```\ngit clone https://github.com/ckj375/hexo-theme-next.git themes/next\n```\n修改仓库根目录下的_config.yml配置项theme\ntheme: next\n\n**选择Scheme**  \nScheme是Next提供的一种特性，借助于Scheme，NexT为你提供多种不同的外观。目前Next支持三种Scheme:\n- Muse - 默认Scheme，这是Next最初的版本，黑白主调，大量留白\n- Mist - Muse的紧凑版本，整洁有序的单栏外观\n- Pisces - 双栏Scheme，小家碧玉似的清新  \n修改主题目录下的_config.yml配置文件  \nscheme: Mist\n\n**设置语言**  \n编辑站点配置文件，将language设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下：language: zh-Hans\n\n**设置菜单**  \n菜单配置包括两个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。\n打开主题配置文件根据需要自行配置：\n```\nMenu Settings\nmenu:\n  home: /\n  #categories: /categories\n  #about: /about\n  archives: /archives\n  tags: /tags\n  #commonweal: /404.html\n```\n\n\n**设置头像**  \n放置在 source/images/ 目录下  \n配置为：avatar: /images/avatar.png\n\n5. 集成第三方服务\n------\n**多说评论**  \n首页选择我要安装，创建站点信息。多说域名这一栏即是你的多说域名，示例：\n```\nhttp://ckj375.duoshuo.com\n```\n在站点配置文件中新增duoshuo_shortname字段   \nduoshuo_shortname: ckj375\n\n**Cnzz统计**  \n注册账号创建站点，进入统计代码页面，有多种统计样式可供选择。\n示例：在themes/next/layout/_partials/目录下新建cnzz_tongji.swig，添加以下代码\n```\n<% if (theme.cnzz){ %>\n<script type=\"text/javascript\">var cnzz_protocol = ((\"https:\" == document.location.protocol) ? \" https://\" : \" http://\");document.write(unescape(\"%3Cspan id='cnzz_stat_icon_1257888989'%3E%3C/span%3E%3Cscript src='\" + cnzz_protocol + \"s4.cnzz.com/z_stat.php%3Fid%3D1257888989%26online%3D2' type='text/javascript'%3E%3C/script%3E\"));</script>\n<% } %>\n```\njs部分可换成自己想要的样式,\n在footer.swig中新增以下代码\n```\n<div class=\"analytics\">\n<script type=\"text/javascript\">var cnzz_protocol = ((\"https:\" == document.location.protocol) ? \" https://\" : \" http://\");document.write(unescape(\"%3Cspan id='cnzz_stat_icon_1257888989'%3E%3C/span%3E%3Cscript src='\" + cnzz_protocol + \"s4.cnzz.com/z_stat.php%3Fid%3D1257888989%26online%3D2' type='text/javascript'%3E%3C/script%3E\"));</script>\n</div>\n```\n同样js部分可自行替换  \n在主题配置文件中启用cnzz统计  \ncnzz_tongji: true\n\n6. 编辑文章\n------\n新建文章\n```\nhexo new \"标题\"\n```\n在 _posts 目录下会生成文件标题.md\n\n```\n---\ntitle: Github Pages上搭建Hexo博客\ndate: 2016-03-16 11:22:55\ntags:\n---\n```\n接下来就用markdown尽情书写吧！\n\n","source":"_posts/github-hexo-blog.md","raw":"---\ntitle: Github上搭建Hexo博客\ndate: 2016-03-16 11:22:55\ntags: Hexo\ncategories: Github\n---\n\n1. 安装Git和NodeJs\n------\n此处略过,不会的童鞋找谷哥...\n\n2. 安装hexo\n------\n去github上创建仓库，name.github.io,示例：ckj375.github.io\n创建2个分支：master和hexo，并设置hexo为默认分支，hexo分支用于存放网站原始文件，master分支用于存放生成的静态网页。\n克隆代码仓  \n```\ngit clone https://github.com/ckj375/ckj375.github.io.git\n```\n进入目录，依次执行以下命令\n```\nhexo init  \nnpm install  \nnpm install hexo-deployer-git --save  \nhexo generate  \nhexo server  \n```\n打开本地浏览器按照提示输入url即可访问本地博客了,若提示找不到hexo server这条指令,输入\n```\nnpm install hexo -server --save\n```\n修改_config.yml中的deploy参数（注意冒号后面要加空格）\n```\ndeploy:  \n    type: git  \n    repo: https://github.com/ckj375/ckj375.github.io.git  \n    branch: master\n```\n网站作者和标题：修改站点配置文件_config.yml的author和title字段\n```\nauthor: chenkaijian\ntitle: 皮皮熊的博客\n```\n通过Git将网站原始文件提交至hexo分支：\n```\ngit push origin hexo\nhexo generate 生成网站\nhexo deploy 将网站部署到github的master（前面已经在站点配置文件_config.yml中配置deploy参数）\n```\n\n3. hexo常用命令\n------\n```\nhexo help #查看帮助  \nhexo init #初始化一个目录  \nhexo new \"postName\" #新建文章  \nhexo new page \"pageName\" #新建页面  \nhexo generate #生成网页，可以在 public 目录查看整个网站的文件  \nhexo server #本地预览  \nhexo deploy #部署.deploy目录  \nhexo clean #清除缓存，建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹\n```\n简写  \n```\nhexo n == hexo new  \nhexo g == hexo generate  \nhexo s == hexo server  \nhexo d == hexo deploy  \n```\n\n4. 主题配置\n------\n个人比较喜欢简约风的主题，所以选了Next主题  \n首先去fork一套next主题源码:https://github.com/iissnan/hexo-theme-next  \n进入仓库根目录克隆最新版本的next主题：\n```\ngit clone https://github.com/ckj375/hexo-theme-next.git themes/next\n```\n修改仓库根目录下的_config.yml配置项theme\ntheme: next\n\n**选择Scheme**  \nScheme是Next提供的一种特性，借助于Scheme，NexT为你提供多种不同的外观。目前Next支持三种Scheme:\n- Muse - 默认Scheme，这是Next最初的版本，黑白主调，大量留白\n- Mist - Muse的紧凑版本，整洁有序的单栏外观\n- Pisces - 双栏Scheme，小家碧玉似的清新  \n修改主题目录下的_config.yml配置文件  \nscheme: Mist\n\n**设置语言**  \n编辑站点配置文件，将language设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下：language: zh-Hans\n\n**设置菜单**  \n菜单配置包括两个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。\n打开主题配置文件根据需要自行配置：\n```\nMenu Settings\nmenu:\n  home: /\n  #categories: /categories\n  #about: /about\n  archives: /archives\n  tags: /tags\n  #commonweal: /404.html\n```\n\n\n**设置头像**  \n放置在 source/images/ 目录下  \n配置为：avatar: /images/avatar.png\n\n5. 集成第三方服务\n------\n**多说评论**  \n首页选择我要安装，创建站点信息。多说域名这一栏即是你的多说域名，示例：\n```\nhttp://ckj375.duoshuo.com\n```\n在站点配置文件中新增duoshuo_shortname字段   \nduoshuo_shortname: ckj375\n\n**Cnzz统计**  \n注册账号创建站点，进入统计代码页面，有多种统计样式可供选择。\n示例：在themes/next/layout/_partials/目录下新建cnzz_tongji.swig，添加以下代码\n```\n<% if (theme.cnzz){ %>\n<script type=\"text/javascript\">var cnzz_protocol = ((\"https:\" == document.location.protocol) ? \" https://\" : \" http://\");document.write(unescape(\"%3Cspan id='cnzz_stat_icon_1257888989'%3E%3C/span%3E%3Cscript src='\" + cnzz_protocol + \"s4.cnzz.com/z_stat.php%3Fid%3D1257888989%26online%3D2' type='text/javascript'%3E%3C/script%3E\"));</script>\n<% } %>\n```\njs部分可换成自己想要的样式,\n在footer.swig中新增以下代码\n```\n<div class=\"analytics\">\n<script type=\"text/javascript\">var cnzz_protocol = ((\"https:\" == document.location.protocol) ? \" https://\" : \" http://\");document.write(unescape(\"%3Cspan id='cnzz_stat_icon_1257888989'%3E%3C/span%3E%3Cscript src='\" + cnzz_protocol + \"s4.cnzz.com/z_stat.php%3Fid%3D1257888989%26online%3D2' type='text/javascript'%3E%3C/script%3E\"));</script>\n</div>\n```\n同样js部分可自行替换  \n在主题配置文件中启用cnzz统计  \ncnzz_tongji: true\n\n6. 编辑文章\n------\n新建文章\n```\nhexo new \"标题\"\n```\n在 _posts 目录下会生成文件标题.md\n\n```\n---\ntitle: Github Pages上搭建Hexo博客\ndate: 2016-03-16 11:22:55\ntags:\n---\n```\n接下来就用markdown尽情书写吧！\n\n","slug":"github-hexo-blog","published":1,"updated":"2016-11-25T08:50:33.764Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civxk0r8g000f7qh7bjqgj5iq","content":"<h2 id=\"1-安装Git和NodeJs\"><a href=\"#1-安装Git和NodeJs\" class=\"headerlink\" title=\"1. 安装Git和NodeJs\"></a>1. 安装Git和NodeJs</h2><p>此处略过,不会的童鞋找谷哥…</p>\n<h2 id=\"2-安装hexo\"><a href=\"#2-安装hexo\" class=\"headerlink\" title=\"2. 安装hexo\"></a>2. 安装hexo</h2><p>去github上创建仓库，name.github.io,示例：ckj375.github.io<br>创建2个分支：master和hexo，并设置hexo为默认分支，hexo分支用于存放网站原始文件，master分支用于存放生成的静态网页。<br>克隆代码仓<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://github.com/ckj375/ckj375.github.io.git</div></pre></td></tr></table></figure></p>\n<p>进入目录，依次执行以下命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init  </div><div class=\"line\">npm install  </div><div class=\"line\">npm install hexo-deployer-git --save  </div><div class=\"line\">hexo generate  </div><div class=\"line\">hexo server</div></pre></td></tr></table></figure></p>\n<p>打开本地浏览器按照提示输入url即可访问本地博客了,若提示找不到hexo server这条指令,输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo -server --save</div></pre></td></tr></table></figure></p>\n<p>修改_config.yml中的deploy参数（注意冒号后面要加空格）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy:  </div><div class=\"line\">    type: git  </div><div class=\"line\">    repo: https://github.com/ckj375/ckj375.github.io.git  </div><div class=\"line\">    branch: master</div></pre></td></tr></table></figure></p>\n<p>网站作者和标题：修改站点配置文件_config.yml的author和title字段<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">author: chenkaijian</div><div class=\"line\">title: 皮皮熊的博客</div></pre></td></tr></table></figure></p>\n<p>通过Git将网站原始文件提交至hexo分支：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git push origin hexo</div><div class=\"line\">hexo generate 生成网站</div><div class=\"line\">hexo deploy 将网站部署到github的master（前面已经在站点配置文件_config.yml中配置deploy参数）</div></pre></td></tr></table></figure></p>\n<h2 id=\"3-hexo常用命令\"><a href=\"#3-hexo常用命令\" class=\"headerlink\" title=\"3. hexo常用命令\"></a>3. hexo常用命令</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo help #查看帮助  </div><div class=\"line\">hexo init #初始化一个目录  </div><div class=\"line\">hexo new &quot;postName&quot; #新建文章  </div><div class=\"line\">hexo new page &quot;pageName&quot; #新建页面  </div><div class=\"line\">hexo generate #生成网页，可以在 public 目录查看整个网站的文件  </div><div class=\"line\">hexo server #本地预览  </div><div class=\"line\">hexo deploy #部署.deploy目录  </div><div class=\"line\">hexo clean #清除缓存，建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹</div></pre></td></tr></table></figure>\n<p>简写<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo n == hexo new  </div><div class=\"line\">hexo g == hexo generate  </div><div class=\"line\">hexo s == hexo server  </div><div class=\"line\">hexo d == hexo deploy</div></pre></td></tr></table></figure></p>\n<h2 id=\"4-主题配置\"><a href=\"#4-主题配置\" class=\"headerlink\" title=\"4. 主题配置\"></a>4. 主题配置</h2><p>个人比较喜欢简约风的主题，所以选了Next主题<br>首先去fork一套next主题源码:<a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"external\">https://github.com/iissnan/hexo-theme-next</a><br>进入仓库根目录克隆最新版本的next主题：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://github.com/ckj375/hexo-theme-next.git themes/next</div></pre></td></tr></table></figure></p>\n<p>修改仓库根目录下的_config.yml配置项theme<br>theme: next</p>\n<p><strong>选择Scheme</strong><br>Scheme是Next提供的一种特性，借助于Scheme，NexT为你提供多种不同的外观。目前Next支持三种Scheme:</p>\n<ul>\n<li>Muse - 默认Scheme，这是Next最初的版本，黑白主调，大量留白</li>\n<li>Mist - Muse的紧凑版本，整洁有序的单栏外观</li>\n<li>Pisces - 双栏Scheme，小家碧玉似的清新<br>修改主题目录下的_config.yml配置文件<br>scheme: Mist</li>\n</ul>\n<p><strong>设置语言</strong><br>编辑站点配置文件，将language设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下：language: zh-Hans</p>\n<p><strong>设置菜单</strong><br>菜单配置包括两个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。<br>打开主题配置文件根据需要自行配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Menu Settings</div><div class=\"line\">menu:</div><div class=\"line\">  home: /</div><div class=\"line\">  #categories: /categories</div><div class=\"line\">  #about: /about</div><div class=\"line\">  archives: /archives</div><div class=\"line\">  tags: /tags</div><div class=\"line\">  #commonweal: /404.html</div></pre></td></tr></table></figure></p>\n<p><strong>设置头像</strong><br>放置在 source/images/ 目录下<br>配置为：avatar: /images/avatar.png</p>\n<h2 id=\"5-集成第三方服务\"><a href=\"#5-集成第三方服务\" class=\"headerlink\" title=\"5. 集成第三方服务\"></a>5. 集成第三方服务</h2><p><strong>多说评论</strong><br>首页选择我要安装，创建站点信息。多说域名这一栏即是你的多说域名，示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://ckj375.duoshuo.com</div></pre></td></tr></table></figure></p>\n<p>在站点配置文件中新增duoshuo_shortname字段<br>duoshuo_shortname: ckj375</p>\n<p><strong>Cnzz统计</strong><br>注册账号创建站点，进入统计代码页面，有多种统计样式可供选择。<br>示例：在themes/next/layout/_partials/目录下新建cnzz_tongji.swig，添加以下代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;% if (theme.cnzz)&#123; %&gt;</div><div class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;var cnzz_protocol = ((&quot;https:&quot; == document.location.protocol) ? &quot; https://&quot; : &quot; http://&quot;);document.write(unescape(&quot;%3Cspan id=&apos;cnzz_stat_icon_1257888989&apos;%3E%3C/span%3E%3Cscript src=&apos;&quot; + cnzz_protocol + &quot;s4.cnzz.com/z_stat.php%3Fid%3D1257888989%26online%3D2&apos; type=&apos;text/javascript&apos;%3E%3C/script%3E&quot;));&lt;/script&gt;</div><div class=\"line\">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure></p>\n<p>js部分可换成自己想要的样式,<br>在footer.swig中新增以下代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;analytics&quot;&gt;</div><div class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;var cnzz_protocol = ((&quot;https:&quot; == document.location.protocol) ? &quot; https://&quot; : &quot; http://&quot;);document.write(unescape(&quot;%3Cspan id=&apos;cnzz_stat_icon_1257888989&apos;%3E%3C/span%3E%3Cscript src=&apos;&quot; + cnzz_protocol + &quot;s4.cnzz.com/z_stat.php%3Fid%3D1257888989%26online%3D2&apos; type=&apos;text/javascript&apos;%3E%3C/script%3E&quot;));&lt;/script&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<p>同样js部分可自行替换<br>在主题配置文件中启用cnzz统计<br>cnzz_tongji: true</p>\n<h2 id=\"6-编辑文章\"><a href=\"#6-编辑文章\" class=\"headerlink\" title=\"6. 编辑文章\"></a>6. 编辑文章</h2><p>新建文章<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new &quot;标题&quot;</div></pre></td></tr></table></figure></p>\n<p>在 _posts 目录下会生成文件标题.md</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: Github Pages上搭建Hexo博客</div><div class=\"line\">date: 2016-03-16 11:22:55</div><div class=\"line\">tags:</div><div class=\"line\">---</div></pre></td></tr></table></figure>\n<p>接下来就用markdown尽情书写吧！</p>\n","excerpt":"","more":"<h2 id=\"1-安装Git和NodeJs\"><a href=\"#1-安装Git和NodeJs\" class=\"headerlink\" title=\"1. 安装Git和NodeJs\"></a>1. 安装Git和NodeJs</h2><p>此处略过,不会的童鞋找谷哥…</p>\n<h2 id=\"2-安装hexo\"><a href=\"#2-安装hexo\" class=\"headerlink\" title=\"2. 安装hexo\"></a>2. 安装hexo</h2><p>去github上创建仓库，name.github.io,示例：ckj375.github.io<br>创建2个分支：master和hexo，并设置hexo为默认分支，hexo分支用于存放网站原始文件，master分支用于存放生成的静态网页。<br>克隆代码仓<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://github.com/ckj375/ckj375.github.io.git</div></pre></td></tr></table></figure></p>\n<p>进入目录，依次执行以下命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init  </div><div class=\"line\">npm install  </div><div class=\"line\">npm install hexo-deployer-git --save  </div><div class=\"line\">hexo generate  </div><div class=\"line\">hexo server</div></pre></td></tr></table></figure></p>\n<p>打开本地浏览器按照提示输入url即可访问本地博客了,若提示找不到hexo server这条指令,输入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo -server --save</div></pre></td></tr></table></figure></p>\n<p>修改_config.yml中的deploy参数（注意冒号后面要加空格）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy:  </div><div class=\"line\">    type: git  </div><div class=\"line\">    repo: https://github.com/ckj375/ckj375.github.io.git  </div><div class=\"line\">    branch: master</div></pre></td></tr></table></figure></p>\n<p>网站作者和标题：修改站点配置文件_config.yml的author和title字段<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">author: chenkaijian</div><div class=\"line\">title: 皮皮熊的博客</div></pre></td></tr></table></figure></p>\n<p>通过Git将网站原始文件提交至hexo分支：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git push origin hexo</div><div class=\"line\">hexo generate 生成网站</div><div class=\"line\">hexo deploy 将网站部署到github的master（前面已经在站点配置文件_config.yml中配置deploy参数）</div></pre></td></tr></table></figure></p>\n<h2 id=\"3-hexo常用命令\"><a href=\"#3-hexo常用命令\" class=\"headerlink\" title=\"3. hexo常用命令\"></a>3. hexo常用命令</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo help #查看帮助  </div><div class=\"line\">hexo init #初始化一个目录  </div><div class=\"line\">hexo new &quot;postName&quot; #新建文章  </div><div class=\"line\">hexo new page &quot;pageName&quot; #新建页面  </div><div class=\"line\">hexo generate #生成网页，可以在 public 目录查看整个网站的文件  </div><div class=\"line\">hexo server #本地预览  </div><div class=\"line\">hexo deploy #部署.deploy目录  </div><div class=\"line\">hexo clean #清除缓存，建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹</div></pre></td></tr></table></figure>\n<p>简写<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo n == hexo new  </div><div class=\"line\">hexo g == hexo generate  </div><div class=\"line\">hexo s == hexo server  </div><div class=\"line\">hexo d == hexo deploy</div></pre></td></tr></table></figure></p>\n<h2 id=\"4-主题配置\"><a href=\"#4-主题配置\" class=\"headerlink\" title=\"4. 主题配置\"></a>4. 主题配置</h2><p>个人比较喜欢简约风的主题，所以选了Next主题<br>首先去fork一套next主题源码:<a href=\"https://github.com/iissnan/hexo-theme-next\">https://github.com/iissnan/hexo-theme-next</a><br>进入仓库根目录克隆最新版本的next主题：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://github.com/ckj375/hexo-theme-next.git themes/next</div></pre></td></tr></table></figure></p>\n<p>修改仓库根目录下的_config.yml配置项theme<br>theme: next</p>\n<p><strong>选择Scheme</strong><br>Scheme是Next提供的一种特性，借助于Scheme，NexT为你提供多种不同的外观。目前Next支持三种Scheme:</p>\n<ul>\n<li>Muse - 默认Scheme，这是Next最初的版本，黑白主调，大量留白</li>\n<li>Mist - Muse的紧凑版本，整洁有序的单栏外观</li>\n<li>Pisces - 双栏Scheme，小家碧玉似的清新<br>修改主题目录下的_config.yml配置文件<br>scheme: Mist</li>\n</ul>\n<p><strong>设置语言</strong><br>编辑站点配置文件，将language设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下：language: zh-Hans</p>\n<p><strong>设置菜单</strong><br>菜单配置包括两个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。<br>打开主题配置文件根据需要自行配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Menu Settings</div><div class=\"line\">menu:</div><div class=\"line\">  home: /</div><div class=\"line\">  #categories: /categories</div><div class=\"line\">  #about: /about</div><div class=\"line\">  archives: /archives</div><div class=\"line\">  tags: /tags</div><div class=\"line\">  #commonweal: /404.html</div></pre></td></tr></table></figure></p>\n<p><strong>设置头像</strong><br>放置在 source/images/ 目录下<br>配置为：avatar: /images/avatar.png</p>\n<h2 id=\"5-集成第三方服务\"><a href=\"#5-集成第三方服务\" class=\"headerlink\" title=\"5. 集成第三方服务\"></a>5. 集成第三方服务</h2><p><strong>多说评论</strong><br>首页选择我要安装，创建站点信息。多说域名这一栏即是你的多说域名，示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://ckj375.duoshuo.com</div></pre></td></tr></table></figure></p>\n<p>在站点配置文件中新增duoshuo_shortname字段<br>duoshuo_shortname: ckj375</p>\n<p><strong>Cnzz统计</strong><br>注册账号创建站点，进入统计代码页面，有多种统计样式可供选择。<br>示例：在themes/next/layout/_partials/目录下新建cnzz_tongji.swig，添加以下代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;% if (theme.cnzz)&#123; %&gt;</div><div class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;var cnzz_protocol = ((&quot;https:&quot; == document.location.protocol) ? &quot; https://&quot; : &quot; http://&quot;);document.write(unescape(&quot;%3Cspan id=&apos;cnzz_stat_icon_1257888989&apos;%3E%3C/span%3E%3Cscript src=&apos;&quot; + cnzz_protocol + &quot;s4.cnzz.com/z_stat.php%3Fid%3D1257888989%26online%3D2&apos; type=&apos;text/javascript&apos;%3E%3C/script%3E&quot;));&lt;/script&gt;</div><div class=\"line\">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure></p>\n<p>js部分可换成自己想要的样式,<br>在footer.swig中新增以下代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;analytics&quot;&gt;</div><div class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;var cnzz_protocol = ((&quot;https:&quot; == document.location.protocol) ? &quot; https://&quot; : &quot; http://&quot;);document.write(unescape(&quot;%3Cspan id=&apos;cnzz_stat_icon_1257888989&apos;%3E%3C/span%3E%3Cscript src=&apos;&quot; + cnzz_protocol + &quot;s4.cnzz.com/z_stat.php%3Fid%3D1257888989%26online%3D2&apos; type=&apos;text/javascript&apos;%3E%3C/script%3E&quot;));&lt;/script&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure></p>\n<p>同样js部分可自行替换<br>在主题配置文件中启用cnzz统计<br>cnzz_tongji: true</p>\n<h2 id=\"6-编辑文章\"><a href=\"#6-编辑文章\" class=\"headerlink\" title=\"6. 编辑文章\"></a>6. 编辑文章</h2><p>新建文章<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new &quot;标题&quot;</div></pre></td></tr></table></figure></p>\n<p>在 _posts 目录下会生成文件标题.md</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">---</div><div class=\"line\">title: Github Pages上搭建Hexo博客</div><div class=\"line\">date: 2016-03-16 11:22:55</div><div class=\"line\">tags:</div><div class=\"line\">---</div></pre></td></tr></table></figure>\n<p>接下来就用markdown尽情书写吧！</p>\n"},{"title":"如何在Android源码中为APK签系统签名？","date":"2016-07-20T08:42:19.000Z","_content":"&#160; &#160; &#160; &#160; 做Android系统项目时经常会用基线代码编译出来的APK push到定制版本的手机里去验证,但\n往往会碰到签名不一致导致APK在桌面不显示的问题,这时候就需要用对应源码对APK重新签名打包.\n1. 找到系统签名文件,文件路径：在源码的\\build\\target\\product\\security目录下有platform.x509pem和platform.pk8两个文件\n\n2. 把签名文件复制到\\out\\host\\linux-x86\\framework目录下\n\n3. 把预签名的apk复制到\\out\\host\\linux-x86\\framework目录下\n\n4. 把编译路径切换到\\out\\host\\linux-x86\\framework目录下，使用java -jar signapk.jar platform.x509.pem platform.pk8 in.apk(预签名的apk) out.apk(签名之后的apk)\n\n[阅读原文](http://ckj375.github.io/2016/07/20/%E5%A6%82%E4%BD%95%E5%9C%A8Android%E6%BA%90%E7%A0%81%E4%B8%AD%E4%B8%BAAPK%E7%AD%BE%E7%B3%BB%E7%BB%9F%E7%AD%BE%E5%90%8D%EF%BC%9F/)\n","source":"_posts/如何在Android源码中为APK签系统签名？.md","raw":"---\ntitle: 如何在Android源码中为APK签系统签名？\ndate: 2016-07-20 16:42:19\ntags: Android签名\ncategories: Android\n---\n&#160; &#160; &#160; &#160; 做Android系统项目时经常会用基线代码编译出来的APK push到定制版本的手机里去验证,但\n往往会碰到签名不一致导致APK在桌面不显示的问题,这时候就需要用对应源码对APK重新签名打包.\n1. 找到系统签名文件,文件路径：在源码的\\build\\target\\product\\security目录下有platform.x509pem和platform.pk8两个文件\n\n2. 把签名文件复制到\\out\\host\\linux-x86\\framework目录下\n\n3. 把预签名的apk复制到\\out\\host\\linux-x86\\framework目录下\n\n4. 把编译路径切换到\\out\\host\\linux-x86\\framework目录下，使用java -jar signapk.jar platform.x509.pem platform.pk8 in.apk(预签名的apk) out.apk(签名之后的apk)\n\n[阅读原文](http://ckj375.github.io/2016/07/20/%E5%A6%82%E4%BD%95%E5%9C%A8Android%E6%BA%90%E7%A0%81%E4%B8%AD%E4%B8%BAAPK%E7%AD%BE%E7%B3%BB%E7%BB%9F%E7%AD%BE%E5%90%8D%EF%BC%9F/)\n","slug":"如何在Android源码中为APK签系统签名？","published":1,"updated":"2016-11-25T08:50:33.764Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civxk0r8n000k7qh75qq0y5bc","content":"<p>&#160; &#160; &#160; &#160; 做Android系统项目时经常会用基线代码编译出来的APK push到定制版本的手机里去验证,但<br>往往会碰到签名不一致导致APK在桌面不显示的问题,这时候就需要用对应源码对APK重新签名打包.</p>\n<ol>\n<li><p>找到系统签名文件,文件路径：在源码的\\build\\target\\product\\security目录下有platform.x509pem和platform.pk8两个文件</p>\n</li>\n<li><p>把签名文件复制到\\out\\host\\linux-x86\\framework目录下</p>\n</li>\n<li><p>把预签名的apk复制到\\out\\host\\linux-x86\\framework目录下</p>\n</li>\n<li><p>把编译路径切换到\\out\\host\\linux-x86\\framework目录下，使用java -jar signapk.jar platform.x509.pem platform.pk8 in.apk(预签名的apk) out.apk(签名之后的apk)</p>\n</li>\n</ol>\n<p><a href=\"http://ckj375.github.io/2016/07/20/%E5%A6%82%E4%BD%95%E5%9C%A8Android%E6%BA%90%E7%A0%81%E4%B8%AD%E4%B8%BAAPK%E7%AD%BE%E7%B3%BB%E7%BB%9F%E7%AD%BE%E5%90%8D%EF%BC%9F/\" target=\"_blank\" rel=\"external\">阅读原文</a></p>\n","excerpt":"","more":"<p>&#160; &#160; &#160; &#160; 做Android系统项目时经常会用基线代码编译出来的APK push到定制版本的手机里去验证,但<br>往往会碰到签名不一致导致APK在桌面不显示的问题,这时候就需要用对应源码对APK重新签名打包.</p>\n<ol>\n<li><p>找到系统签名文件,文件路径：在源码的\\build\\target\\product\\security目录下有platform.x509pem和platform.pk8两个文件</p>\n</li>\n<li><p>把签名文件复制到\\out\\host\\linux-x86\\framework目录下</p>\n</li>\n<li><p>把预签名的apk复制到\\out\\host\\linux-x86\\framework目录下</p>\n</li>\n<li><p>把编译路径切换到\\out\\host\\linux-x86\\framework目录下，使用java -jar signapk.jar platform.x509.pem platform.pk8 in.apk(预签名的apk) out.apk(签名之后的apk)</p>\n</li>\n</ol>\n<p><a href=\"http://ckj375.github.io/2016/07/20/%E5%A6%82%E4%BD%95%E5%9C%A8Android%E6%BA%90%E7%A0%81%E4%B8%AD%E4%B8%BAAPK%E7%AD%BE%E7%B3%BB%E7%BB%9F%E7%AD%BE%E5%90%8D%EF%BC%9F/\">阅读原文</a></p>\n"},{"title":"Android贴图功能详解","date":"2016-09-08T01:29:59.000Z","_content":"\n### 前言\n随着美图贴贴，天天P图，in的火热，越来越多的人喜欢贴图，朋友圈里的好友尤其是妹子喜欢把照片贴上各种搞怪或呆萌的道具。去年公司说要做一款主打原创素材的贴图应用，BB猪满怀欣喜的接下了这个任务，现在把贴图功能的具体实现分享出来。\n### 需求\n应用自带一部分默认素材，根据类别进入素材浏览界面，选中某一具体素材后，跳转至编辑界面，在编辑界面可对素材进行旋转，缩放，移动，删除操作，支持添加多个素材，最终保存。美图贴贴界面如下:\n<div align=center>\n![img](http://o6xqhzzif.bkt.clouddn.com/hexo/android-sticker/meitutietie.jpg)\n</div>\n\n### 分析\nBB猪冥思一想，有了初步方案：使用自定义View去实现道具的旋转，缩放，移动等基本操作。\n自定义一个贴图控件StickerView，继承至View。StickerView模型图如下:\n\n<div align=center>\n![img](http://o6xqhzzif.bkt.clouddn.com/hexo/android-sticker/stickerview-model1.jpg)\n</div>\n\n先定义4个常量分别表示:左上角删除按钮,右下角旋转缩放按钮,中心点,其他点。\n\n    public static final int CTR_LEFT_TOP = 0;  \n    public static final int CTR_RIGHT_BOTTOM = 2;  \n    public static final int CTR_MID_MID = 4;  \n    public static final int CTR_NONE = -1;  \n    public int current_ctr = CTR_NONE;  \n\n定义3个Bitmap：mainBmp , deleteBmp ,controlBmp分别对应素材图本身，删除按钮和旋转缩放按钮。\n\n    private Bitmap mainBmp , deleteBmp ,controlBmp ;\n    private int mainBmpWidth , mainBmpHeight , deleteBmpWidth , deleteBmpHeight , controlBmpWidth , controlBmpHeight ;    \n\n<div align=center>\n    ![img](http://o6xqhzzif.bkt.clouddn.com/hexo/android-sticker/stickerview-model2.jpg)\n</div>\n\n定义两个数组srcPs和dstPs,分别用于记录矩形转换(旋转,移动,缩放)前后的各点坐标。  \n\n    private float[] srcPs, dstPs;\n\n\n看下构造器，构造器中主要做两件事：传入素材图url和调用初始化方法initData  \n\n    public StickerView(Context context , String imgPath){\n        super(context);\n        this.context = context ;\n        this.imgPath = imgPath;\n        initData(imgPath);\n    }\n\ninitData方法主要是初始化Bitmap和坐标数组:\n\n    private void initData(String imgPath) {\n    mainBmp = BitmapFactory.decodeFile(imgPath);\n    deleteBmp = BitmapFactory.decodeResource(this.context.getResources(), R.drawable.ic_f_delete_normal);\n    controlBmp = BitmapFactory.decodeResource(this.context.getResources(), R.drawable.ic_f_rotate_normal);\n    mainBmpWidth = mainBmp.getWidth();\n    mainBmpHeight = mainBmp.getHeight();\n    deleteBmpWidth = deleteBmp.getWidth();\n    deleteBmpHeight = deleteBmp.getHeight();\n    controlBmpWidth = controlBmp.getWidth();\n    controlBmpHeight = controlBmp.getHeight();\n\n    srcPs = new float[]{\n            0, 0,\n            mainBmpWidth, 0,\n            mainBmpWidth, mainBmpHeight,\n            0, mainBmpHeight,\n            mainBmpWidth / 2, mainBmpHeight / 2\n    };\n    dstPs = srcPs.clone();\n\n    matrix = new Matrix();\n\n    // 平移后中心点位置\n    prePivot = new Point(mainBmpWidth / 2, mainBmpHeight / 2);\n    // 平移前中心点位置\n    lastPivot = new Point(mainBmpWidth / 2, mainBmpHeight / 2);\n\n    // 上一次触摸点位置\n    lastPoint = new Point(0, 0);\n\n    paint = new Paint();\n\n    paintFrame = new Paint();\n    paintFrame.setColor(Color.WHITE);\n    paintFrame.setAntiAlias(true);\n\n    defaultDegree = lastDegree = computeDegree(new Point(mainBmpWidth, mainBmpHeight), new Point(mainBmpWidth / 2, mainBmpHeight / 2));\n\n    setMatrix(OPER_DEFAULT);\n    }\n\n接下来看一下StickerView的绘制流程:  \n定义一个标志位isSelected，如果处于选中状态就显示边框和操作按钮，反之不显示。\n\n    public void onDraw(Canvas canvas) {\n        if (!isActive) {\n            return;\n        }\n        canvas.drawBitmap(mainBmp, matrix, paint);//绘制主图片\n        if (isSelected) {\n            drawFrame(canvas);//绘制边框,以便测试点的映射\n            drawControlPoints(canvas);//绘制控制点图片\n        }\n\n    }\n\n\n绘制边框\n\n      private void drawFrame(Canvas canvas) {\n        canvas.drawLine(dstPs[0], dstPs[1], dstPs[2], dstPs[3], paintFrame);\n        canvas.drawLine(dstPs[2], dstPs[3], dstPs[4], dstPs[5], paintFrame);\n        canvas.drawLine(dstPs[4], dstPs[5], dstPs[6], dstPs[7], paintFrame);\n        canvas.drawLine(dstPs[0], dstPs[1], dstPs[6], dstPs[7], paintFrame);\n    }\n\n绘制操作按钮  \n\n    private void drawControlPoints(Canvas canvas) {\n        canvas.drawBitmap(deleteBmp, dstPs[0] - deleteBmpWidth / 2, dstPs[1] - deleteBmpHeight / 2, paint);\n        canvas.drawBitmap(controlBmp, dstPs[4] - controlBmpWidth / 2, dstPs[5] - controlBmpHeight / 2, paint);\n    }  \n\n\n<div align=center>\n        ![img](http://o6xqhzzif.bkt.clouddn.com/hexo/android-sticker/stickerview-demo1.jpg)\n</div>\n\n接下来就是重点了,StickerView的Touch事件处理:  \n若触摸点不在StickerView上并且不在删除按钮和旋转按钮上，则将StickerView设置为非选中状态并隐藏边框和操作按钮；  \n若触摸点在删除按钮上，则隐藏该素材；  \n若触摸点在旋转缩放按钮处，则进行旋转缩放操作；  \n若触摸点在StickerView的其他位置，则进行移动操作。\n\n     public boolean onTouchEvent(MotionEvent event) {\n        int evX = (int) event.getX();\n        int evY = (int) event.getY();\n\n        if (!isOnPic(evX, evY) && isOnCP(evX, evY) == CTR_NONE) {\n            isSelected = false;\n            invalidate();\n        } else if (isOnCP(evX, evY) == CTR_LEFT_TOP) {\n            isActive = false;\n            invalidate();\n        } else {\n            int operType = OPER_DEFAULT;\n            operType = getOperationType(event);\n\n            switch (operType) {\n                case OPER_TRANSLATE:\n                    if (isOnPic(evX, evY)) {\n                        translate(evX, evY);\n                    }\n                    break;\n                case OPER_ROTATE:\n                    rotate(event);\n                    scale(event);\n                    break;\n            }\n\n            lastPoint.x = evX;\n            lastPoint.y = evY;\n\n            lastOper = operType;\n            isSelected = true;\n            invalidate();\n        }\n\n        return true;\n    }\n\n判断触摸点是否在贴图上  \n\n    private boolean isOnPic(int x, int y) {\n        // 获取逆向矩阵\n        Matrix inMatrix = new Matrix();\n        matrix.invert(inMatrix);\n\n        float[] tempPs = new float[]{0, 0};\n        inMatrix.mapPoints(tempPs, new float[]{x, y});\n        if (tempPs[0] > 0 && tempPs[0] < mainBmp.getWidth() && tempPs[1] > 0 && tempPs[1] < mainBmp.getHeight()) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n判断点所在的控制点\n\n    private int isOnCP(int evx, int evy) {\n        Rect rect = new Rect(evx - controlBmpWidth / 2, evy - controlBmpHeight / 2, evx + controlBmpWidth / 2, evy + controlBmpHeight / 2);\n        int res = 0;\n        for (int i = 0; i < dstPs.length; i += 2) {\n            if (rect.contains((int) dstPs[i], (int) dstPs[i + 1])) {\n                return res;\n            }\n            ++res;\n        }\n        return CTR_NONE;\n    }\n\n定义StickerView的操作类型:移动,旋转,缩放,选择  \n\n    public static final int OPER_DEFAULT = -1;      //默认  \n    public static final int OPER_TRANSLATE = 0;     //移动  \n    public static final int OPER_SCALE = 1;         //缩放  \n    public static final int OPER_ROTATE = 2;        //旋转  \n    public static final int OPER_SELECTED = 3;      //选择  \n    public int lastOper = OPER_SELECTED;\n\n    private int getOperationType(MotionEvent event) {\n\n        int evX = (int) event.getX();\n        int evY = (int) event.getY();\n        int curOper = lastOper;\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_DOWN:\n                current_ctr = isOnCP(evX, evY);\n                if (current_ctr != CTR_NONE || isOnPic(evX, evY)) {\n                    curOper = OPER_SELECTED;\n                }\n                break;\n            case MotionEvent.ACTION_MOVE:\n                if (current_ctr == CTR_LEFT_TOP) {\n                    // 删除饰品\n                } else if (current_ctr == CTR_RIGHT_BOTTOM) {\n                    curOper = OPER_ROTATE;\n                } else if (lastOper == OPER_SELECTED) {\n                    curOper = OPER_TRANSLATE;\n                }\n                break;\n            case MotionEvent.ACTION_UP:\n                curOper = OPER_SELECTED;\n                break;\n            default:\n                break;\n        }\n        return curOper;\n\n    }\n\n通过Matrix实现移动,旋转,缩放:  \n\n    private void translate(int evx, int evy) {\n\n        prePivot.x += evx - lastPoint.x;\n        prePivot.y += evy - lastPoint.y;\n\n        deltaX = prePivot.x - lastPivot.x;\n        deltaY = prePivot.y - lastPivot.y;\n\n        lastPivot.x = prePivot.x;\n        lastPivot.y = prePivot.y;\n\n        setMatrix(OPER_TRANSLATE); //设置矩阵\n\n    }\n\n    private void scale(MotionEvent event) {\n\n        int pointIndex = current_ctr * 2;\n\n        float px = dstPs[pointIndex];\n        float py = dstPs[pointIndex + 1];\n\n        float evx = event.getX();\n        float evy = event.getY();\n\n        float oppositeX = 0;\n        float oppositeY = 0;\n\n        oppositeX = dstPs[pointIndex - 4];\n        oppositeY = dstPs[pointIndex - 3];\n\n        float temp1 = getDistanceOfTwoPoints(px, py, oppositeX, oppositeY);\n        float temp2 = getDistanceOfTwoPoints(evx, evy, oppositeX, oppositeY);\n\n        this.scaleValue = temp2 / temp1;\n        symmetricPoint.x = (int) oppositeX;\n        symmetricPoint.y = (int) oppositeY;\n        centerPoint.x = (int) (symmetricPoint.x + px) / 2;\n        centerPoint.y = (int) (symmetricPoint.y + py) / 2;\n        rightBottomPoint.x = (int) dstPs[8];\n        rightBottomPoint.y = (int) dstPs[9];\n        Log.i(\"img\", \"scaleValue is \" + scaleValue);\n        if (getScaleValue() < (float) 0.5 && scaleValue < (float) 1) {\n            // 限定最小缩放比为0.5\n        } else {\n            setMatrix(OPER_SCALE);\n        }\n    }\n\n    private void rotate(MotionEvent event) {\n\n        if (event.getPointerCount() == 2) {\n            preDegree = computeDegree(new Point((int) event.getX(0), (int) event.getY(0)), new Point((int) event.getX(1), (int) event.getY(1)));\n        } else {\n            preDegree = computeDegree(new Point((int) event.getX(), (int) event.getY()), new Point((int) dstPs[8], (int) dstPs[9]));\n        }\n        setMatrix(OPER_ROTATE);\n        lastDegree = preDegree;\n    }\n\n    private void setMatrix(int operationType) {\n        switch (operationType) {\n            case OPER_TRANSLATE:\n                matrix.postTranslate(deltaX, deltaY);\n                break;\n            case OPER_SCALE:\n                matrix.postScale(scaleValue, scaleValue, dstPs[CTR_MID_MID * 2], dstPs[CTR_MID_MID * 2 + 1]);\n                break;\n            case OPER_ROTATE:\n                matrix.postRotate(preDegree - lastDegree, dstPs[CTR_MID_MID * 2], dstPs[CTR_MID_MID * 2 + 1]);\n                break;\n        }\n\n        matrix.mapPoints(dstPs, srcPs);\n    }\n\n最后看下素材的添加保存流程:在主界面点击素材按钮进入素材选择界面,选中素材后通过onActivityResult获取图片url,初始化StickerView,并通过addView方法添加至容器中,并通过ArrayList<StickerView>保存已添加的所有素材道具,然后遍历将素材图和背景图依次合成新的Bitmap,最后保存至手机目录中。\n\n    private Bitmap createBitmap(Bitmap src, Bitmap dst, float[] centerPoint, float degree, float scaleValue) {\n    if (src == null) {\n        return null;\n    }\n    int w = src.getWidth();\n    int h = src.getHeight();\n    DisplayMetrics metric = new DisplayMetrics();\n    getWindowManager().getDefaultDisplay().getMetrics(metric);\n    int width = metric.widthPixels;     // 屏幕宽度（像素）\n    float scale = (float) w / (float) width;\n\n    int ww = dst.getWidth();\n    int wh = dst.getHeight();\n\n    float Ltx = centerPoint[0] - img.getLeft() - ww * scaleValue / 2;\n    float Lty = centerPoint[1] - img.getTop() - wh * scaleValue / 2;\n\n    Bitmap newb = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);//创建一个新的和SRC长度宽度一样的位图\n    Canvas cv = new Canvas(newb);\n    cv.drawBitmap(src, 0, 0, null);//在 0，0坐标开始画入src\n\n    // 定义矩阵对象\n    Matrix matrix = new Matrix();\n    matrix.postScale(scaleValue, scaleValue);\n    //matrix.postRotate(degree);\n    cv.save();\n    cv.rotate(degree, centerPoint[0], centerPoint[1]);\n    Bitmap dstbmp = Bitmap.createBitmap(dst, 0, 0, dst.getWidth(), dst.getHeight(),\n            matrix, true);\n    cv.drawBitmap(dstbmp, Ltx * scale, Lty * scale, null);//在src画贴图\n    //cv.save( Canvas.ALL_SAVE_FLAG );//保存\n    cv.restore();//存储\n    return newb;\n    }\n\n项目地址:https://github.com/ckj375/Android-Sticker.git   \n效果图:\n<div align=center>\n            ![img](http://o6xqhzzif.bkt.clouddn.com/hexo/android-sticker/stickerview.gif)\n</div>\n\n[(转载请注明出处,谢谢)](http://ckj375.github.io/2016/09/08/android-sticker/)\n","source":"_posts/android-sticker.md","raw":"---\ntitle: Android贴图功能详解\ndate: 2016-09-08 09:29:59\ntags: 贴图\ncategories: Android\n---\n\n### 前言\n随着美图贴贴，天天P图，in的火热，越来越多的人喜欢贴图，朋友圈里的好友尤其是妹子喜欢把照片贴上各种搞怪或呆萌的道具。去年公司说要做一款主打原创素材的贴图应用，BB猪满怀欣喜的接下了这个任务，现在把贴图功能的具体实现分享出来。\n### 需求\n应用自带一部分默认素材，根据类别进入素材浏览界面，选中某一具体素材后，跳转至编辑界面，在编辑界面可对素材进行旋转，缩放，移动，删除操作，支持添加多个素材，最终保存。美图贴贴界面如下:\n<div align=center>\n![img](http://o6xqhzzif.bkt.clouddn.com/hexo/android-sticker/meitutietie.jpg)\n</div>\n\n### 分析\nBB猪冥思一想，有了初步方案：使用自定义View去实现道具的旋转，缩放，移动等基本操作。\n自定义一个贴图控件StickerView，继承至View。StickerView模型图如下:\n\n<div align=center>\n![img](http://o6xqhzzif.bkt.clouddn.com/hexo/android-sticker/stickerview-model1.jpg)\n</div>\n\n先定义4个常量分别表示:左上角删除按钮,右下角旋转缩放按钮,中心点,其他点。\n\n    public static final int CTR_LEFT_TOP = 0;  \n    public static final int CTR_RIGHT_BOTTOM = 2;  \n    public static final int CTR_MID_MID = 4;  \n    public static final int CTR_NONE = -1;  \n    public int current_ctr = CTR_NONE;  \n\n定义3个Bitmap：mainBmp , deleteBmp ,controlBmp分别对应素材图本身，删除按钮和旋转缩放按钮。\n\n    private Bitmap mainBmp , deleteBmp ,controlBmp ;\n    private int mainBmpWidth , mainBmpHeight , deleteBmpWidth , deleteBmpHeight , controlBmpWidth , controlBmpHeight ;    \n\n<div align=center>\n    ![img](http://o6xqhzzif.bkt.clouddn.com/hexo/android-sticker/stickerview-model2.jpg)\n</div>\n\n定义两个数组srcPs和dstPs,分别用于记录矩形转换(旋转,移动,缩放)前后的各点坐标。  \n\n    private float[] srcPs, dstPs;\n\n\n看下构造器，构造器中主要做两件事：传入素材图url和调用初始化方法initData  \n\n    public StickerView(Context context , String imgPath){\n        super(context);\n        this.context = context ;\n        this.imgPath = imgPath;\n        initData(imgPath);\n    }\n\ninitData方法主要是初始化Bitmap和坐标数组:\n\n    private void initData(String imgPath) {\n    mainBmp = BitmapFactory.decodeFile(imgPath);\n    deleteBmp = BitmapFactory.decodeResource(this.context.getResources(), R.drawable.ic_f_delete_normal);\n    controlBmp = BitmapFactory.decodeResource(this.context.getResources(), R.drawable.ic_f_rotate_normal);\n    mainBmpWidth = mainBmp.getWidth();\n    mainBmpHeight = mainBmp.getHeight();\n    deleteBmpWidth = deleteBmp.getWidth();\n    deleteBmpHeight = deleteBmp.getHeight();\n    controlBmpWidth = controlBmp.getWidth();\n    controlBmpHeight = controlBmp.getHeight();\n\n    srcPs = new float[]{\n            0, 0,\n            mainBmpWidth, 0,\n            mainBmpWidth, mainBmpHeight,\n            0, mainBmpHeight,\n            mainBmpWidth / 2, mainBmpHeight / 2\n    };\n    dstPs = srcPs.clone();\n\n    matrix = new Matrix();\n\n    // 平移后中心点位置\n    prePivot = new Point(mainBmpWidth / 2, mainBmpHeight / 2);\n    // 平移前中心点位置\n    lastPivot = new Point(mainBmpWidth / 2, mainBmpHeight / 2);\n\n    // 上一次触摸点位置\n    lastPoint = new Point(0, 0);\n\n    paint = new Paint();\n\n    paintFrame = new Paint();\n    paintFrame.setColor(Color.WHITE);\n    paintFrame.setAntiAlias(true);\n\n    defaultDegree = lastDegree = computeDegree(new Point(mainBmpWidth, mainBmpHeight), new Point(mainBmpWidth / 2, mainBmpHeight / 2));\n\n    setMatrix(OPER_DEFAULT);\n    }\n\n接下来看一下StickerView的绘制流程:  \n定义一个标志位isSelected，如果处于选中状态就显示边框和操作按钮，反之不显示。\n\n    public void onDraw(Canvas canvas) {\n        if (!isActive) {\n            return;\n        }\n        canvas.drawBitmap(mainBmp, matrix, paint);//绘制主图片\n        if (isSelected) {\n            drawFrame(canvas);//绘制边框,以便测试点的映射\n            drawControlPoints(canvas);//绘制控制点图片\n        }\n\n    }\n\n\n绘制边框\n\n      private void drawFrame(Canvas canvas) {\n        canvas.drawLine(dstPs[0], dstPs[1], dstPs[2], dstPs[3], paintFrame);\n        canvas.drawLine(dstPs[2], dstPs[3], dstPs[4], dstPs[5], paintFrame);\n        canvas.drawLine(dstPs[4], dstPs[5], dstPs[6], dstPs[7], paintFrame);\n        canvas.drawLine(dstPs[0], dstPs[1], dstPs[6], dstPs[7], paintFrame);\n    }\n\n绘制操作按钮  \n\n    private void drawControlPoints(Canvas canvas) {\n        canvas.drawBitmap(deleteBmp, dstPs[0] - deleteBmpWidth / 2, dstPs[1] - deleteBmpHeight / 2, paint);\n        canvas.drawBitmap(controlBmp, dstPs[4] - controlBmpWidth / 2, dstPs[5] - controlBmpHeight / 2, paint);\n    }  \n\n\n<div align=center>\n        ![img](http://o6xqhzzif.bkt.clouddn.com/hexo/android-sticker/stickerview-demo1.jpg)\n</div>\n\n接下来就是重点了,StickerView的Touch事件处理:  \n若触摸点不在StickerView上并且不在删除按钮和旋转按钮上，则将StickerView设置为非选中状态并隐藏边框和操作按钮；  \n若触摸点在删除按钮上，则隐藏该素材；  \n若触摸点在旋转缩放按钮处，则进行旋转缩放操作；  \n若触摸点在StickerView的其他位置，则进行移动操作。\n\n     public boolean onTouchEvent(MotionEvent event) {\n        int evX = (int) event.getX();\n        int evY = (int) event.getY();\n\n        if (!isOnPic(evX, evY) && isOnCP(evX, evY) == CTR_NONE) {\n            isSelected = false;\n            invalidate();\n        } else if (isOnCP(evX, evY) == CTR_LEFT_TOP) {\n            isActive = false;\n            invalidate();\n        } else {\n            int operType = OPER_DEFAULT;\n            operType = getOperationType(event);\n\n            switch (operType) {\n                case OPER_TRANSLATE:\n                    if (isOnPic(evX, evY)) {\n                        translate(evX, evY);\n                    }\n                    break;\n                case OPER_ROTATE:\n                    rotate(event);\n                    scale(event);\n                    break;\n            }\n\n            lastPoint.x = evX;\n            lastPoint.y = evY;\n\n            lastOper = operType;\n            isSelected = true;\n            invalidate();\n        }\n\n        return true;\n    }\n\n判断触摸点是否在贴图上  \n\n    private boolean isOnPic(int x, int y) {\n        // 获取逆向矩阵\n        Matrix inMatrix = new Matrix();\n        matrix.invert(inMatrix);\n\n        float[] tempPs = new float[]{0, 0};\n        inMatrix.mapPoints(tempPs, new float[]{x, y});\n        if (tempPs[0] > 0 && tempPs[0] < mainBmp.getWidth() && tempPs[1] > 0 && tempPs[1] < mainBmp.getHeight()) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n判断点所在的控制点\n\n    private int isOnCP(int evx, int evy) {\n        Rect rect = new Rect(evx - controlBmpWidth / 2, evy - controlBmpHeight / 2, evx + controlBmpWidth / 2, evy + controlBmpHeight / 2);\n        int res = 0;\n        for (int i = 0; i < dstPs.length; i += 2) {\n            if (rect.contains((int) dstPs[i], (int) dstPs[i + 1])) {\n                return res;\n            }\n            ++res;\n        }\n        return CTR_NONE;\n    }\n\n定义StickerView的操作类型:移动,旋转,缩放,选择  \n\n    public static final int OPER_DEFAULT = -1;      //默认  \n    public static final int OPER_TRANSLATE = 0;     //移动  \n    public static final int OPER_SCALE = 1;         //缩放  \n    public static final int OPER_ROTATE = 2;        //旋转  \n    public static final int OPER_SELECTED = 3;      //选择  \n    public int lastOper = OPER_SELECTED;\n\n    private int getOperationType(MotionEvent event) {\n\n        int evX = (int) event.getX();\n        int evY = (int) event.getY();\n        int curOper = lastOper;\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_DOWN:\n                current_ctr = isOnCP(evX, evY);\n                if (current_ctr != CTR_NONE || isOnPic(evX, evY)) {\n                    curOper = OPER_SELECTED;\n                }\n                break;\n            case MotionEvent.ACTION_MOVE:\n                if (current_ctr == CTR_LEFT_TOP) {\n                    // 删除饰品\n                } else if (current_ctr == CTR_RIGHT_BOTTOM) {\n                    curOper = OPER_ROTATE;\n                } else if (lastOper == OPER_SELECTED) {\n                    curOper = OPER_TRANSLATE;\n                }\n                break;\n            case MotionEvent.ACTION_UP:\n                curOper = OPER_SELECTED;\n                break;\n            default:\n                break;\n        }\n        return curOper;\n\n    }\n\n通过Matrix实现移动,旋转,缩放:  \n\n    private void translate(int evx, int evy) {\n\n        prePivot.x += evx - lastPoint.x;\n        prePivot.y += evy - lastPoint.y;\n\n        deltaX = prePivot.x - lastPivot.x;\n        deltaY = prePivot.y - lastPivot.y;\n\n        lastPivot.x = prePivot.x;\n        lastPivot.y = prePivot.y;\n\n        setMatrix(OPER_TRANSLATE); //设置矩阵\n\n    }\n\n    private void scale(MotionEvent event) {\n\n        int pointIndex = current_ctr * 2;\n\n        float px = dstPs[pointIndex];\n        float py = dstPs[pointIndex + 1];\n\n        float evx = event.getX();\n        float evy = event.getY();\n\n        float oppositeX = 0;\n        float oppositeY = 0;\n\n        oppositeX = dstPs[pointIndex - 4];\n        oppositeY = dstPs[pointIndex - 3];\n\n        float temp1 = getDistanceOfTwoPoints(px, py, oppositeX, oppositeY);\n        float temp2 = getDistanceOfTwoPoints(evx, evy, oppositeX, oppositeY);\n\n        this.scaleValue = temp2 / temp1;\n        symmetricPoint.x = (int) oppositeX;\n        symmetricPoint.y = (int) oppositeY;\n        centerPoint.x = (int) (symmetricPoint.x + px) / 2;\n        centerPoint.y = (int) (symmetricPoint.y + py) / 2;\n        rightBottomPoint.x = (int) dstPs[8];\n        rightBottomPoint.y = (int) dstPs[9];\n        Log.i(\"img\", \"scaleValue is \" + scaleValue);\n        if (getScaleValue() < (float) 0.5 && scaleValue < (float) 1) {\n            // 限定最小缩放比为0.5\n        } else {\n            setMatrix(OPER_SCALE);\n        }\n    }\n\n    private void rotate(MotionEvent event) {\n\n        if (event.getPointerCount() == 2) {\n            preDegree = computeDegree(new Point((int) event.getX(0), (int) event.getY(0)), new Point((int) event.getX(1), (int) event.getY(1)));\n        } else {\n            preDegree = computeDegree(new Point((int) event.getX(), (int) event.getY()), new Point((int) dstPs[8], (int) dstPs[9]));\n        }\n        setMatrix(OPER_ROTATE);\n        lastDegree = preDegree;\n    }\n\n    private void setMatrix(int operationType) {\n        switch (operationType) {\n            case OPER_TRANSLATE:\n                matrix.postTranslate(deltaX, deltaY);\n                break;\n            case OPER_SCALE:\n                matrix.postScale(scaleValue, scaleValue, dstPs[CTR_MID_MID * 2], dstPs[CTR_MID_MID * 2 + 1]);\n                break;\n            case OPER_ROTATE:\n                matrix.postRotate(preDegree - lastDegree, dstPs[CTR_MID_MID * 2], dstPs[CTR_MID_MID * 2 + 1]);\n                break;\n        }\n\n        matrix.mapPoints(dstPs, srcPs);\n    }\n\n最后看下素材的添加保存流程:在主界面点击素材按钮进入素材选择界面,选中素材后通过onActivityResult获取图片url,初始化StickerView,并通过addView方法添加至容器中,并通过ArrayList<StickerView>保存已添加的所有素材道具,然后遍历将素材图和背景图依次合成新的Bitmap,最后保存至手机目录中。\n\n    private Bitmap createBitmap(Bitmap src, Bitmap dst, float[] centerPoint, float degree, float scaleValue) {\n    if (src == null) {\n        return null;\n    }\n    int w = src.getWidth();\n    int h = src.getHeight();\n    DisplayMetrics metric = new DisplayMetrics();\n    getWindowManager().getDefaultDisplay().getMetrics(metric);\n    int width = metric.widthPixels;     // 屏幕宽度（像素）\n    float scale = (float) w / (float) width;\n\n    int ww = dst.getWidth();\n    int wh = dst.getHeight();\n\n    float Ltx = centerPoint[0] - img.getLeft() - ww * scaleValue / 2;\n    float Lty = centerPoint[1] - img.getTop() - wh * scaleValue / 2;\n\n    Bitmap newb = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);//创建一个新的和SRC长度宽度一样的位图\n    Canvas cv = new Canvas(newb);\n    cv.drawBitmap(src, 0, 0, null);//在 0，0坐标开始画入src\n\n    // 定义矩阵对象\n    Matrix matrix = new Matrix();\n    matrix.postScale(scaleValue, scaleValue);\n    //matrix.postRotate(degree);\n    cv.save();\n    cv.rotate(degree, centerPoint[0], centerPoint[1]);\n    Bitmap dstbmp = Bitmap.createBitmap(dst, 0, 0, dst.getWidth(), dst.getHeight(),\n            matrix, true);\n    cv.drawBitmap(dstbmp, Ltx * scale, Lty * scale, null);//在src画贴图\n    //cv.save( Canvas.ALL_SAVE_FLAG );//保存\n    cv.restore();//存储\n    return newb;\n    }\n\n项目地址:https://github.com/ckj375/Android-Sticker.git   \n效果图:\n<div align=center>\n            ![img](http://o6xqhzzif.bkt.clouddn.com/hexo/android-sticker/stickerview.gif)\n</div>\n\n[(转载请注明出处,谢谢)](http://ckj375.github.io/2016/09/08/android-sticker/)\n","slug":"android-sticker","published":1,"updated":"2016-11-25T08:50:33.764Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civxk0r8o000l7qh72sq8fcuy","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>随着美图贴贴，天天P图，in的火热，越来越多的人喜欢贴图，朋友圈里的好友尤其是妹子喜欢把照片贴上各种搞怪或呆萌的道具。去年公司说要做一款主打原创素材的贴图应用，BB猪满怀欣喜的接下了这个任务，现在把贴图功能的具体实现分享出来。</p>\n<h3 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h3><p>应用自带一部分默认素材，根据类别进入素材浏览界面，选中某一具体素材后，跳转至编辑界面，在编辑界面可对素材进行旋转，缩放，移动，删除操作，支持添加多个素材，最终保存。美图贴贴界面如下:</p>\n<div align=\"center\"><br><img src=\"http://o6xqhzzif.bkt.clouddn.com/hexo/android-sticker/meitutietie.jpg\" alt=\"img\"><br></div>\n\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>BB猪冥思一想，有了初步方案：使用自定义View去实现道具的旋转，缩放，移动等基本操作。<br>自定义一个贴图控件StickerView，继承至View。StickerView模型图如下:</p>\n<div align=\"center\"><br><img src=\"http://o6xqhzzif.bkt.clouddn.com/hexo/android-sticker/stickerview-model1.jpg\" alt=\"img\"><br></div>\n\n<p>先定义4个常量分别表示:左上角删除按钮,右下角旋转缩放按钮,中心点,其他点。</p>\n<pre><code>public static final int CTR_LEFT_TOP = 0;  \npublic static final int CTR_RIGHT_BOTTOM = 2;  \npublic static final int CTR_MID_MID = 4;  \npublic static final int CTR_NONE = -1;  \npublic int current_ctr = CTR_NONE;  \n</code></pre><p>定义3个Bitmap：mainBmp , deleteBmp ,controlBmp分别对应素材图本身，删除按钮和旋转缩放按钮。</p>\n<pre><code>private Bitmap mainBmp , deleteBmp ,controlBmp ;\nprivate int mainBmpWidth , mainBmpHeight , deleteBmpWidth , deleteBmpHeight , controlBmpWidth , controlBmpHeight ;    \n</code></pre><div align=\"center\"><br>    <img src=\"http://o6xqhzzif.bkt.clouddn.com/hexo/android-sticker/stickerview-model2.jpg\" alt=\"img\"><br></div>\n\n<p>定义两个数组srcPs和dstPs,分别用于记录矩形转换(旋转,移动,缩放)前后的各点坐标。  </p>\n<pre><code>private float[] srcPs, dstPs;\n</code></pre><p>看下构造器，构造器中主要做两件事：传入素材图url和调用初始化方法initData  </p>\n<pre><code>public StickerView(Context context , String imgPath){\n    super(context);\n    this.context = context ;\n    this.imgPath = imgPath;\n    initData(imgPath);\n}\n</code></pre><p>initData方法主要是初始化Bitmap和坐标数组:</p>\n<pre><code>private void initData(String imgPath) {\nmainBmp = BitmapFactory.decodeFile(imgPath);\ndeleteBmp = BitmapFactory.decodeResource(this.context.getResources(), R.drawable.ic_f_delete_normal);\ncontrolBmp = BitmapFactory.decodeResource(this.context.getResources(), R.drawable.ic_f_rotate_normal);\nmainBmpWidth = mainBmp.getWidth();\nmainBmpHeight = mainBmp.getHeight();\ndeleteBmpWidth = deleteBmp.getWidth();\ndeleteBmpHeight = deleteBmp.getHeight();\ncontrolBmpWidth = controlBmp.getWidth();\ncontrolBmpHeight = controlBmp.getHeight();\n\nsrcPs = new float[]{\n        0, 0,\n        mainBmpWidth, 0,\n        mainBmpWidth, mainBmpHeight,\n        0, mainBmpHeight,\n        mainBmpWidth / 2, mainBmpHeight / 2\n};\ndstPs = srcPs.clone();\n\nmatrix = new Matrix();\n\n// 平移后中心点位置\nprePivot = new Point(mainBmpWidth / 2, mainBmpHeight / 2);\n// 平移前中心点位置\nlastPivot = new Point(mainBmpWidth / 2, mainBmpHeight / 2);\n\n// 上一次触摸点位置\nlastPoint = new Point(0, 0);\n\npaint = new Paint();\n\npaintFrame = new Paint();\npaintFrame.setColor(Color.WHITE);\npaintFrame.setAntiAlias(true);\n\ndefaultDegree = lastDegree = computeDegree(new Point(mainBmpWidth, mainBmpHeight), new Point(mainBmpWidth / 2, mainBmpHeight / 2));\n\nsetMatrix(OPER_DEFAULT);\n}\n</code></pre><p>接下来看一下StickerView的绘制流程:<br>定义一个标志位isSelected，如果处于选中状态就显示边框和操作按钮，反之不显示。</p>\n<pre><code>public void onDraw(Canvas canvas) {\n    if (!isActive) {\n        return;\n    }\n    canvas.drawBitmap(mainBmp, matrix, paint);//绘制主图片\n    if (isSelected) {\n        drawFrame(canvas);//绘制边框,以便测试点的映射\n        drawControlPoints(canvas);//绘制控制点图片\n    }\n\n}\n</code></pre><p>绘制边框</p>\n<pre><code>  private void drawFrame(Canvas canvas) {\n    canvas.drawLine(dstPs[0], dstPs[1], dstPs[2], dstPs[3], paintFrame);\n    canvas.drawLine(dstPs[2], dstPs[3], dstPs[4], dstPs[5], paintFrame);\n    canvas.drawLine(dstPs[4], dstPs[5], dstPs[6], dstPs[7], paintFrame);\n    canvas.drawLine(dstPs[0], dstPs[1], dstPs[6], dstPs[7], paintFrame);\n}\n</code></pre><p>绘制操作按钮  </p>\n<pre><code>private void drawControlPoints(Canvas canvas) {\n    canvas.drawBitmap(deleteBmp, dstPs[0] - deleteBmpWidth / 2, dstPs[1] - deleteBmpHeight / 2, paint);\n    canvas.drawBitmap(controlBmp, dstPs[4] - controlBmpWidth / 2, dstPs[5] - controlBmpHeight / 2, paint);\n}  \n</code></pre><div align=\"center\"><br>        <img src=\"http://o6xqhzzif.bkt.clouddn.com/hexo/android-sticker/stickerview-demo1.jpg\" alt=\"img\"><br></div>\n\n<p>接下来就是重点了,StickerView的Touch事件处理:<br>若触摸点不在StickerView上并且不在删除按钮和旋转按钮上，则将StickerView设置为非选中状态并隐藏边框和操作按钮；<br>若触摸点在删除按钮上，则隐藏该素材；<br>若触摸点在旋转缩放按钮处，则进行旋转缩放操作；<br>若触摸点在StickerView的其他位置，则进行移动操作。</p>\n<pre><code> public boolean onTouchEvent(MotionEvent event) {\n    int evX = (int) event.getX();\n    int evY = (int) event.getY();\n\n    if (!isOnPic(evX, evY) &amp;&amp; isOnCP(evX, evY) == CTR_NONE) {\n        isSelected = false;\n        invalidate();\n    } else if (isOnCP(evX, evY) == CTR_LEFT_TOP) {\n        isActive = false;\n        invalidate();\n    } else {\n        int operType = OPER_DEFAULT;\n        operType = getOperationType(event);\n\n        switch (operType) {\n            case OPER_TRANSLATE:\n                if (isOnPic(evX, evY)) {\n                    translate(evX, evY);\n                }\n                break;\n            case OPER_ROTATE:\n                rotate(event);\n                scale(event);\n                break;\n        }\n\n        lastPoint.x = evX;\n        lastPoint.y = evY;\n\n        lastOper = operType;\n        isSelected = true;\n        invalidate();\n    }\n\n    return true;\n}\n</code></pre><p>判断触摸点是否在贴图上  </p>\n<pre><code>private boolean isOnPic(int x, int y) {\n    // 获取逆向矩阵\n    Matrix inMatrix = new Matrix();\n    matrix.invert(inMatrix);\n\n    float[] tempPs = new float[]{0, 0};\n    inMatrix.mapPoints(tempPs, new float[]{x, y});\n    if (tempPs[0] &gt; 0 &amp;&amp; tempPs[0] &lt; mainBmp.getWidth() &amp;&amp; tempPs[1] &gt; 0 &amp;&amp; tempPs[1] &lt; mainBmp.getHeight()) {\n        return true;\n    } else {\n        return false;\n    }\n}\n</code></pre><p>判断点所在的控制点</p>\n<pre><code>private int isOnCP(int evx, int evy) {\n    Rect rect = new Rect(evx - controlBmpWidth / 2, evy - controlBmpHeight / 2, evx + controlBmpWidth / 2, evy + controlBmpHeight / 2);\n    int res = 0;\n    for (int i = 0; i &lt; dstPs.length; i += 2) {\n        if (rect.contains((int) dstPs[i], (int) dstPs[i + 1])) {\n            return res;\n        }\n        ++res;\n    }\n    return CTR_NONE;\n}\n</code></pre><p>定义StickerView的操作类型:移动,旋转,缩放,选择  </p>\n<pre><code>public static final int OPER_DEFAULT = -1;      //默认  \npublic static final int OPER_TRANSLATE = 0;     //移动  \npublic static final int OPER_SCALE = 1;         //缩放  \npublic static final int OPER_ROTATE = 2;        //旋转  \npublic static final int OPER_SELECTED = 3;      //选择  \npublic int lastOper = OPER_SELECTED;\n\nprivate int getOperationType(MotionEvent event) {\n\n    int evX = (int) event.getX();\n    int evY = (int) event.getY();\n    int curOper = lastOper;\n    switch (event.getAction()) {\n        case MotionEvent.ACTION_DOWN:\n            current_ctr = isOnCP(evX, evY);\n            if (current_ctr != CTR_NONE || isOnPic(evX, evY)) {\n                curOper = OPER_SELECTED;\n            }\n            break;\n        case MotionEvent.ACTION_MOVE:\n            if (current_ctr == CTR_LEFT_TOP) {\n                // 删除饰品\n            } else if (current_ctr == CTR_RIGHT_BOTTOM) {\n                curOper = OPER_ROTATE;\n            } else if (lastOper == OPER_SELECTED) {\n                curOper = OPER_TRANSLATE;\n            }\n            break;\n        case MotionEvent.ACTION_UP:\n            curOper = OPER_SELECTED;\n            break;\n        default:\n            break;\n    }\n    return curOper;\n\n}\n</code></pre><p>通过Matrix实现移动,旋转,缩放:  </p>\n<pre><code>private void translate(int evx, int evy) {\n\n    prePivot.x += evx - lastPoint.x;\n    prePivot.y += evy - lastPoint.y;\n\n    deltaX = prePivot.x - lastPivot.x;\n    deltaY = prePivot.y - lastPivot.y;\n\n    lastPivot.x = prePivot.x;\n    lastPivot.y = prePivot.y;\n\n    setMatrix(OPER_TRANSLATE); //设置矩阵\n\n}\n\nprivate void scale(MotionEvent event) {\n\n    int pointIndex = current_ctr * 2;\n\n    float px = dstPs[pointIndex];\n    float py = dstPs[pointIndex + 1];\n\n    float evx = event.getX();\n    float evy = event.getY();\n\n    float oppositeX = 0;\n    float oppositeY = 0;\n\n    oppositeX = dstPs[pointIndex - 4];\n    oppositeY = dstPs[pointIndex - 3];\n\n    float temp1 = getDistanceOfTwoPoints(px, py, oppositeX, oppositeY);\n    float temp2 = getDistanceOfTwoPoints(evx, evy, oppositeX, oppositeY);\n\n    this.scaleValue = temp2 / temp1;\n    symmetricPoint.x = (int) oppositeX;\n    symmetricPoint.y = (int) oppositeY;\n    centerPoint.x = (int) (symmetricPoint.x + px) / 2;\n    centerPoint.y = (int) (symmetricPoint.y + py) / 2;\n    rightBottomPoint.x = (int) dstPs[8];\n    rightBottomPoint.y = (int) dstPs[9];\n    Log.i(&quot;img&quot;, &quot;scaleValue is &quot; + scaleValue);\n    if (getScaleValue() &lt; (float) 0.5 &amp;&amp; scaleValue &lt; (float) 1) {\n        // 限定最小缩放比为0.5\n    } else {\n        setMatrix(OPER_SCALE);\n    }\n}\n\nprivate void rotate(MotionEvent event) {\n\n    if (event.getPointerCount() == 2) {\n        preDegree = computeDegree(new Point((int) event.getX(0), (int) event.getY(0)), new Point((int) event.getX(1), (int) event.getY(1)));\n    } else {\n        preDegree = computeDegree(new Point((int) event.getX(), (int) event.getY()), new Point((int) dstPs[8], (int) dstPs[9]));\n    }\n    setMatrix(OPER_ROTATE);\n    lastDegree = preDegree;\n}\n\nprivate void setMatrix(int operationType) {\n    switch (operationType) {\n        case OPER_TRANSLATE:\n            matrix.postTranslate(deltaX, deltaY);\n            break;\n        case OPER_SCALE:\n            matrix.postScale(scaleValue, scaleValue, dstPs[CTR_MID_MID * 2], dstPs[CTR_MID_MID * 2 + 1]);\n            break;\n        case OPER_ROTATE:\n            matrix.postRotate(preDegree - lastDegree, dstPs[CTR_MID_MID * 2], dstPs[CTR_MID_MID * 2 + 1]);\n            break;\n    }\n\n    matrix.mapPoints(dstPs, srcPs);\n}\n</code></pre><p>最后看下素材的添加保存流程:在主界面点击素材按钮进入素材选择界面,选中素材后通过onActivityResult获取图片url,初始化StickerView,并通过addView方法添加至容器中,并通过ArrayList<stickerview>保存已添加的所有素材道具,然后遍历将素材图和背景图依次合成新的Bitmap,最后保存至手机目录中。</stickerview></p>\n<pre><code>private Bitmap createBitmap(Bitmap src, Bitmap dst, float[] centerPoint, float degree, float scaleValue) {\nif (src == null) {\n    return null;\n}\nint w = src.getWidth();\nint h = src.getHeight();\nDisplayMetrics metric = new DisplayMetrics();\ngetWindowManager().getDefaultDisplay().getMetrics(metric);\nint width = metric.widthPixels;     // 屏幕宽度（像素）\nfloat scale = (float) w / (float) width;\n\nint ww = dst.getWidth();\nint wh = dst.getHeight();\n\nfloat Ltx = centerPoint[0] - img.getLeft() - ww * scaleValue / 2;\nfloat Lty = centerPoint[1] - img.getTop() - wh * scaleValue / 2;\n\nBitmap newb = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);//创建一个新的和SRC长度宽度一样的位图\nCanvas cv = new Canvas(newb);\ncv.drawBitmap(src, 0, 0, null);//在 0，0坐标开始画入src\n\n// 定义矩阵对象\nMatrix matrix = new Matrix();\nmatrix.postScale(scaleValue, scaleValue);\n//matrix.postRotate(degree);\ncv.save();\ncv.rotate(degree, centerPoint[0], centerPoint[1]);\nBitmap dstbmp = Bitmap.createBitmap(dst, 0, 0, dst.getWidth(), dst.getHeight(),\n        matrix, true);\ncv.drawBitmap(dstbmp, Ltx * scale, Lty * scale, null);//在src画贴图\n//cv.save( Canvas.ALL_SAVE_FLAG );//保存\ncv.restore();//存储\nreturn newb;\n}\n</code></pre><p>项目地址:<a href=\"https://github.com/ckj375/Android-Sticker.git\" target=\"_blank\" rel=\"external\">https://github.com/ckj375/Android-Sticker.git</a><br>效果图:</p>\n<div align=\"center\"><br>            <img src=\"http://o6xqhzzif.bkt.clouddn.com/hexo/android-sticker/stickerview.gif\" alt=\"img\"><br></div>\n\n<p><a href=\"http://ckj375.github.io/2016/09/08/android-sticker/\" target=\"_blank\" rel=\"external\">(转载请注明出处,谢谢)</a></p>\n","excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>随着美图贴贴，天天P图，in的火热，越来越多的人喜欢贴图，朋友圈里的好友尤其是妹子喜欢把照片贴上各种搞怪或呆萌的道具。去年公司说要做一款主打原创素材的贴图应用，BB猪满怀欣喜的接下了这个任务，现在把贴图功能的具体实现分享出来。</p>\n<h3 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h3><p>应用自带一部分默认素材，根据类别进入素材浏览界面，选中某一具体素材后，跳转至编辑界面，在编辑界面可对素材进行旋转，缩放，移动，删除操作，支持添加多个素材，最终保存。美图贴贴界面如下:</p>\n<div align=center><br><img src=\"http://o6xqhzzif.bkt.clouddn.com/hexo/android-sticker/meitutietie.jpg\" alt=\"img\"><br></div>\n\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>BB猪冥思一想，有了初步方案：使用自定义View去实现道具的旋转，缩放，移动等基本操作。<br>自定义一个贴图控件StickerView，继承至View。StickerView模型图如下:</p>\n<div align=center><br><img src=\"http://o6xqhzzif.bkt.clouddn.com/hexo/android-sticker/stickerview-model1.jpg\" alt=\"img\"><br></div>\n\n<p>先定义4个常量分别表示:左上角删除按钮,右下角旋转缩放按钮,中心点,其他点。</p>\n<pre><code>public static final int CTR_LEFT_TOP = 0;  \npublic static final int CTR_RIGHT_BOTTOM = 2;  \npublic static final int CTR_MID_MID = 4;  \npublic static final int CTR_NONE = -1;  \npublic int current_ctr = CTR_NONE;  \n</code></pre><p>定义3个Bitmap：mainBmp , deleteBmp ,controlBmp分别对应素材图本身，删除按钮和旋转缩放按钮。</p>\n<pre><code>private Bitmap mainBmp , deleteBmp ,controlBmp ;\nprivate int mainBmpWidth , mainBmpHeight , deleteBmpWidth , deleteBmpHeight , controlBmpWidth , controlBmpHeight ;    \n</code></pre><div align=center><br>    <img src=\"http://o6xqhzzif.bkt.clouddn.com/hexo/android-sticker/stickerview-model2.jpg\" alt=\"img\"><br></div>\n\n<p>定义两个数组srcPs和dstPs,分别用于记录矩形转换(旋转,移动,缩放)前后的各点坐标。  </p>\n<pre><code>private float[] srcPs, dstPs;\n</code></pre><p>看下构造器，构造器中主要做两件事：传入素材图url和调用初始化方法initData  </p>\n<pre><code>public StickerView(Context context , String imgPath){\n    super(context);\n    this.context = context ;\n    this.imgPath = imgPath;\n    initData(imgPath);\n}\n</code></pre><p>initData方法主要是初始化Bitmap和坐标数组:</p>\n<pre><code>private void initData(String imgPath) {\nmainBmp = BitmapFactory.decodeFile(imgPath);\ndeleteBmp = BitmapFactory.decodeResource(this.context.getResources(), R.drawable.ic_f_delete_normal);\ncontrolBmp = BitmapFactory.decodeResource(this.context.getResources(), R.drawable.ic_f_rotate_normal);\nmainBmpWidth = mainBmp.getWidth();\nmainBmpHeight = mainBmp.getHeight();\ndeleteBmpWidth = deleteBmp.getWidth();\ndeleteBmpHeight = deleteBmp.getHeight();\ncontrolBmpWidth = controlBmp.getWidth();\ncontrolBmpHeight = controlBmp.getHeight();\n\nsrcPs = new float[]{\n        0, 0,\n        mainBmpWidth, 0,\n        mainBmpWidth, mainBmpHeight,\n        0, mainBmpHeight,\n        mainBmpWidth / 2, mainBmpHeight / 2\n};\ndstPs = srcPs.clone();\n\nmatrix = new Matrix();\n\n// 平移后中心点位置\nprePivot = new Point(mainBmpWidth / 2, mainBmpHeight / 2);\n// 平移前中心点位置\nlastPivot = new Point(mainBmpWidth / 2, mainBmpHeight / 2);\n\n// 上一次触摸点位置\nlastPoint = new Point(0, 0);\n\npaint = new Paint();\n\npaintFrame = new Paint();\npaintFrame.setColor(Color.WHITE);\npaintFrame.setAntiAlias(true);\n\ndefaultDegree = lastDegree = computeDegree(new Point(mainBmpWidth, mainBmpHeight), new Point(mainBmpWidth / 2, mainBmpHeight / 2));\n\nsetMatrix(OPER_DEFAULT);\n}\n</code></pre><p>接下来看一下StickerView的绘制流程:<br>定义一个标志位isSelected，如果处于选中状态就显示边框和操作按钮，反之不显示。</p>\n<pre><code>public void onDraw(Canvas canvas) {\n    if (!isActive) {\n        return;\n    }\n    canvas.drawBitmap(mainBmp, matrix, paint);//绘制主图片\n    if (isSelected) {\n        drawFrame(canvas);//绘制边框,以便测试点的映射\n        drawControlPoints(canvas);//绘制控制点图片\n    }\n\n}\n</code></pre><p>绘制边框</p>\n<pre><code>  private void drawFrame(Canvas canvas) {\n    canvas.drawLine(dstPs[0], dstPs[1], dstPs[2], dstPs[3], paintFrame);\n    canvas.drawLine(dstPs[2], dstPs[3], dstPs[4], dstPs[5], paintFrame);\n    canvas.drawLine(dstPs[4], dstPs[5], dstPs[6], dstPs[7], paintFrame);\n    canvas.drawLine(dstPs[0], dstPs[1], dstPs[6], dstPs[7], paintFrame);\n}\n</code></pre><p>绘制操作按钮  </p>\n<pre><code>private void drawControlPoints(Canvas canvas) {\n    canvas.drawBitmap(deleteBmp, dstPs[0] - deleteBmpWidth / 2, dstPs[1] - deleteBmpHeight / 2, paint);\n    canvas.drawBitmap(controlBmp, dstPs[4] - controlBmpWidth / 2, dstPs[5] - controlBmpHeight / 2, paint);\n}  \n</code></pre><div align=center><br>        <img src=\"http://o6xqhzzif.bkt.clouddn.com/hexo/android-sticker/stickerview-demo1.jpg\" alt=\"img\"><br></div>\n\n<p>接下来就是重点了,StickerView的Touch事件处理:<br>若触摸点不在StickerView上并且不在删除按钮和旋转按钮上，则将StickerView设置为非选中状态并隐藏边框和操作按钮；<br>若触摸点在删除按钮上，则隐藏该素材；<br>若触摸点在旋转缩放按钮处，则进行旋转缩放操作；<br>若触摸点在StickerView的其他位置，则进行移动操作。</p>\n<pre><code> public boolean onTouchEvent(MotionEvent event) {\n    int evX = (int) event.getX();\n    int evY = (int) event.getY();\n\n    if (!isOnPic(evX, evY) &amp;&amp; isOnCP(evX, evY) == CTR_NONE) {\n        isSelected = false;\n        invalidate();\n    } else if (isOnCP(evX, evY) == CTR_LEFT_TOP) {\n        isActive = false;\n        invalidate();\n    } else {\n        int operType = OPER_DEFAULT;\n        operType = getOperationType(event);\n\n        switch (operType) {\n            case OPER_TRANSLATE:\n                if (isOnPic(evX, evY)) {\n                    translate(evX, evY);\n                }\n                break;\n            case OPER_ROTATE:\n                rotate(event);\n                scale(event);\n                break;\n        }\n\n        lastPoint.x = evX;\n        lastPoint.y = evY;\n\n        lastOper = operType;\n        isSelected = true;\n        invalidate();\n    }\n\n    return true;\n}\n</code></pre><p>判断触摸点是否在贴图上  </p>\n<pre><code>private boolean isOnPic(int x, int y) {\n    // 获取逆向矩阵\n    Matrix inMatrix = new Matrix();\n    matrix.invert(inMatrix);\n\n    float[] tempPs = new float[]{0, 0};\n    inMatrix.mapPoints(tempPs, new float[]{x, y});\n    if (tempPs[0] &gt; 0 &amp;&amp; tempPs[0] &lt; mainBmp.getWidth() &amp;&amp; tempPs[1] &gt; 0 &amp;&amp; tempPs[1] &lt; mainBmp.getHeight()) {\n        return true;\n    } else {\n        return false;\n    }\n}\n</code></pre><p>判断点所在的控制点</p>\n<pre><code>private int isOnCP(int evx, int evy) {\n    Rect rect = new Rect(evx - controlBmpWidth / 2, evy - controlBmpHeight / 2, evx + controlBmpWidth / 2, evy + controlBmpHeight / 2);\n    int res = 0;\n    for (int i = 0; i &lt; dstPs.length; i += 2) {\n        if (rect.contains((int) dstPs[i], (int) dstPs[i + 1])) {\n            return res;\n        }\n        ++res;\n    }\n    return CTR_NONE;\n}\n</code></pre><p>定义StickerView的操作类型:移动,旋转,缩放,选择  </p>\n<pre><code>public static final int OPER_DEFAULT = -1;      //默认  \npublic static final int OPER_TRANSLATE = 0;     //移动  \npublic static final int OPER_SCALE = 1;         //缩放  \npublic static final int OPER_ROTATE = 2;        //旋转  \npublic static final int OPER_SELECTED = 3;      //选择  \npublic int lastOper = OPER_SELECTED;\n\nprivate int getOperationType(MotionEvent event) {\n\n    int evX = (int) event.getX();\n    int evY = (int) event.getY();\n    int curOper = lastOper;\n    switch (event.getAction()) {\n        case MotionEvent.ACTION_DOWN:\n            current_ctr = isOnCP(evX, evY);\n            if (current_ctr != CTR_NONE || isOnPic(evX, evY)) {\n                curOper = OPER_SELECTED;\n            }\n            break;\n        case MotionEvent.ACTION_MOVE:\n            if (current_ctr == CTR_LEFT_TOP) {\n                // 删除饰品\n            } else if (current_ctr == CTR_RIGHT_BOTTOM) {\n                curOper = OPER_ROTATE;\n            } else if (lastOper == OPER_SELECTED) {\n                curOper = OPER_TRANSLATE;\n            }\n            break;\n        case MotionEvent.ACTION_UP:\n            curOper = OPER_SELECTED;\n            break;\n        default:\n            break;\n    }\n    return curOper;\n\n}\n</code></pre><p>通过Matrix实现移动,旋转,缩放:  </p>\n<pre><code>private void translate(int evx, int evy) {\n\n    prePivot.x += evx - lastPoint.x;\n    prePivot.y += evy - lastPoint.y;\n\n    deltaX = prePivot.x - lastPivot.x;\n    deltaY = prePivot.y - lastPivot.y;\n\n    lastPivot.x = prePivot.x;\n    lastPivot.y = prePivot.y;\n\n    setMatrix(OPER_TRANSLATE); //设置矩阵\n\n}\n\nprivate void scale(MotionEvent event) {\n\n    int pointIndex = current_ctr * 2;\n\n    float px = dstPs[pointIndex];\n    float py = dstPs[pointIndex + 1];\n\n    float evx = event.getX();\n    float evy = event.getY();\n\n    float oppositeX = 0;\n    float oppositeY = 0;\n\n    oppositeX = dstPs[pointIndex - 4];\n    oppositeY = dstPs[pointIndex - 3];\n\n    float temp1 = getDistanceOfTwoPoints(px, py, oppositeX, oppositeY);\n    float temp2 = getDistanceOfTwoPoints(evx, evy, oppositeX, oppositeY);\n\n    this.scaleValue = temp2 / temp1;\n    symmetricPoint.x = (int) oppositeX;\n    symmetricPoint.y = (int) oppositeY;\n    centerPoint.x = (int) (symmetricPoint.x + px) / 2;\n    centerPoint.y = (int) (symmetricPoint.y + py) / 2;\n    rightBottomPoint.x = (int) dstPs[8];\n    rightBottomPoint.y = (int) dstPs[9];\n    Log.i(&quot;img&quot;, &quot;scaleValue is &quot; + scaleValue);\n    if (getScaleValue() &lt; (float) 0.5 &amp;&amp; scaleValue &lt; (float) 1) {\n        // 限定最小缩放比为0.5\n    } else {\n        setMatrix(OPER_SCALE);\n    }\n}\n\nprivate void rotate(MotionEvent event) {\n\n    if (event.getPointerCount() == 2) {\n        preDegree = computeDegree(new Point((int) event.getX(0), (int) event.getY(0)), new Point((int) event.getX(1), (int) event.getY(1)));\n    } else {\n        preDegree = computeDegree(new Point((int) event.getX(), (int) event.getY()), new Point((int) dstPs[8], (int) dstPs[9]));\n    }\n    setMatrix(OPER_ROTATE);\n    lastDegree = preDegree;\n}\n\nprivate void setMatrix(int operationType) {\n    switch (operationType) {\n        case OPER_TRANSLATE:\n            matrix.postTranslate(deltaX, deltaY);\n            break;\n        case OPER_SCALE:\n            matrix.postScale(scaleValue, scaleValue, dstPs[CTR_MID_MID * 2], dstPs[CTR_MID_MID * 2 + 1]);\n            break;\n        case OPER_ROTATE:\n            matrix.postRotate(preDegree - lastDegree, dstPs[CTR_MID_MID * 2], dstPs[CTR_MID_MID * 2 + 1]);\n            break;\n    }\n\n    matrix.mapPoints(dstPs, srcPs);\n}\n</code></pre><p>最后看下素材的添加保存流程:在主界面点击素材按钮进入素材选择界面,选中素材后通过onActivityResult获取图片url,初始化StickerView,并通过addView方法添加至容器中,并通过ArrayList<StickerView>保存已添加的所有素材道具,然后遍历将素材图和背景图依次合成新的Bitmap,最后保存至手机目录中。</p>\n<pre><code>private Bitmap createBitmap(Bitmap src, Bitmap dst, float[] centerPoint, float degree, float scaleValue) {\nif (src == null) {\n    return null;\n}\nint w = src.getWidth();\nint h = src.getHeight();\nDisplayMetrics metric = new DisplayMetrics();\ngetWindowManager().getDefaultDisplay().getMetrics(metric);\nint width = metric.widthPixels;     // 屏幕宽度（像素）\nfloat scale = (float) w / (float) width;\n\nint ww = dst.getWidth();\nint wh = dst.getHeight();\n\nfloat Ltx = centerPoint[0] - img.getLeft() - ww * scaleValue / 2;\nfloat Lty = centerPoint[1] - img.getTop() - wh * scaleValue / 2;\n\nBitmap newb = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);//创建一个新的和SRC长度宽度一样的位图\nCanvas cv = new Canvas(newb);\ncv.drawBitmap(src, 0, 0, null);//在 0，0坐标开始画入src\n\n// 定义矩阵对象\nMatrix matrix = new Matrix();\nmatrix.postScale(scaleValue, scaleValue);\n//matrix.postRotate(degree);\ncv.save();\ncv.rotate(degree, centerPoint[0], centerPoint[1]);\nBitmap dstbmp = Bitmap.createBitmap(dst, 0, 0, dst.getWidth(), dst.getHeight(),\n        matrix, true);\ncv.drawBitmap(dstbmp, Ltx * scale, Lty * scale, null);//在src画贴图\n//cv.save( Canvas.ALL_SAVE_FLAG );//保存\ncv.restore();//存储\nreturn newb;\n}\n</code></pre><p>项目地址:<a href=\"https://github.com/ckj375/Android-Sticker.git\">https://github.com/ckj375/Android-Sticker.git</a><br>效果图:</p>\n<div align=center><br>            <img src=\"http://o6xqhzzif.bkt.clouddn.com/hexo/android-sticker/stickerview.gif\" alt=\"img\"><br></div>\n\n<p><a href=\"http://ckj375.github.io/2016/09/08/android-sticker/\">(转载请注明出处,谢谢)</a></p>\n"},{"title":"搬瓦工VPS搭建PPTP VPN","date":"2016-07-28T06:51:32.000Z","_content":"\n\n之前一直在用神器Lantern和Nydus(20元一个月)，感觉还不错，但是各有各的不足！\n于是开始自己动手折腾用VPS搭建VPN...\n上网逛了一圈，最后选择了搬瓦工的VPS：512RAM，10G SSD，1000G/月，19.9$/年，用了个优惠码，最后用支付宝付了19刀。\n\n下面具体介绍下如何创建PPTP VPN:\n\n### 1.进入搬瓦工控制面板界面\n\n点击stop按钮，选择左侧的Install new OS，推荐装Centos 6 x86\n\n![img](http://o6xqhzzif.bkt.clouddn.com/hexo/bandwagon/control_panel.png)\n\n### 2.安装完毕后可以直接选择Root shell-interactive启动命令窗口\n![img](http://o6xqhzzif.bkt.clouddn.com/hexo/bandwagon/shell_window.png)\n\n### 3.安装一键PPTP VPN\n\nwget http://www.hi-vps.com/shell/vpn_centos6.sh\n\nsh vpn_centos6.sh\n\n选择1自动安装VPN，安装完成后，会自动生成一个默认的VPN用户名和随机密码。\n![img](http://o6xqhzzif.bkt.clouddn.com/hexo/bandwagon/install_window.png)\n\n### 4.添加任意VPN账号\n\nsh vpn_centos6.sh\n\n选择3即可手动添加用户名和密码\n\n[阅读原文](http://ckj375.github.io/2016/07/28/%E6%90%AC%E7%93%A6%E5%B7%A5VPS%E6%90%AD%E5%BB%BAPPTP-VPN/)\n","source":"_posts/搬瓦工VPS搭建PPTP-VPN.md","raw":"---\ntitle: 搬瓦工VPS搭建PPTP VPN\ndate: 2016-07-28 14:51:32\ntags: VPN\ncategories: VPN\n---\n\n\n之前一直在用神器Lantern和Nydus(20元一个月)，感觉还不错，但是各有各的不足！\n于是开始自己动手折腾用VPS搭建VPN...\n上网逛了一圈，最后选择了搬瓦工的VPS：512RAM，10G SSD，1000G/月，19.9$/年，用了个优惠码，最后用支付宝付了19刀。\n\n下面具体介绍下如何创建PPTP VPN:\n\n### 1.进入搬瓦工控制面板界面\n\n点击stop按钮，选择左侧的Install new OS，推荐装Centos 6 x86\n\n![img](http://o6xqhzzif.bkt.clouddn.com/hexo/bandwagon/control_panel.png)\n\n### 2.安装完毕后可以直接选择Root shell-interactive启动命令窗口\n![img](http://o6xqhzzif.bkt.clouddn.com/hexo/bandwagon/shell_window.png)\n\n### 3.安装一键PPTP VPN\n\nwget http://www.hi-vps.com/shell/vpn_centos6.sh\n\nsh vpn_centos6.sh\n\n选择1自动安装VPN，安装完成后，会自动生成一个默认的VPN用户名和随机密码。\n![img](http://o6xqhzzif.bkt.clouddn.com/hexo/bandwagon/install_window.png)\n\n### 4.添加任意VPN账号\n\nsh vpn_centos6.sh\n\n选择3即可手动添加用户名和密码\n\n[阅读原文](http://ckj375.github.io/2016/07/28/%E6%90%AC%E7%93%A6%E5%B7%A5VPS%E6%90%AD%E5%BB%BAPPTP-VPN/)\n","slug":"搬瓦工VPS搭建PPTP-VPN","published":1,"updated":"2016-11-25T08:50:33.764Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civxk0r8r000n7qh73ha3x9h4","content":"<p>之前一直在用神器Lantern和Nydus(20元一个月)，感觉还不错，但是各有各的不足！<br>于是开始自己动手折腾用VPS搭建VPN…<br>上网逛了一圈，最后选择了搬瓦工的VPS：512RAM，10G SSD，1000G/月，19.9$/年，用了个优惠码，最后用支付宝付了19刀。</p>\n<p>下面具体介绍下如何创建PPTP VPN:</p>\n<h3 id=\"1-进入搬瓦工控制面板界面\"><a href=\"#1-进入搬瓦工控制面板界面\" class=\"headerlink\" title=\"1.进入搬瓦工控制面板界面\"></a>1.进入搬瓦工控制面板界面</h3><p>点击stop按钮，选择左侧的Install new OS，推荐装Centos 6 x86</p>\n<p><img src=\"http://o6xqhzzif.bkt.clouddn.com/hexo/bandwagon/control_panel.png\" alt=\"img\"></p>\n<h3 id=\"2-安装完毕后可以直接选择Root-shell-interactive启动命令窗口\"><a href=\"#2-安装完毕后可以直接选择Root-shell-interactive启动命令窗口\" class=\"headerlink\" title=\"2.安装完毕后可以直接选择Root shell-interactive启动命令窗口\"></a>2.安装完毕后可以直接选择Root shell-interactive启动命令窗口</h3><p><img src=\"http://o6xqhzzif.bkt.clouddn.com/hexo/bandwagon/shell_window.png\" alt=\"img\"></p>\n<h3 id=\"3-安装一键PPTP-VPN\"><a href=\"#3-安装一键PPTP-VPN\" class=\"headerlink\" title=\"3.安装一键PPTP VPN\"></a>3.安装一键PPTP VPN</h3><p>wget <a href=\"http://www.hi-vps.com/shell/vpn_centos6.sh\" target=\"_blank\" rel=\"external\">http://www.hi-vps.com/shell/vpn_centos6.sh</a></p>\n<p>sh vpn_centos6.sh</p>\n<p>选择1自动安装VPN，安装完成后，会自动生成一个默认的VPN用户名和随机密码。<br><img src=\"http://o6xqhzzif.bkt.clouddn.com/hexo/bandwagon/install_window.png\" alt=\"img\"></p>\n<h3 id=\"4-添加任意VPN账号\"><a href=\"#4-添加任意VPN账号\" class=\"headerlink\" title=\"4.添加任意VPN账号\"></a>4.添加任意VPN账号</h3><p>sh vpn_centos6.sh</p>\n<p>选择3即可手动添加用户名和密码</p>\n<p><a href=\"http://ckj375.github.io/2016/07/28/%E6%90%AC%E7%93%A6%E5%B7%A5VPS%E6%90%AD%E5%BB%BAPPTP-VPN/\" target=\"_blank\" rel=\"external\">阅读原文</a></p>\n","excerpt":"","more":"<p>之前一直在用神器Lantern和Nydus(20元一个月)，感觉还不错，但是各有各的不足！<br>于是开始自己动手折腾用VPS搭建VPN…<br>上网逛了一圈，最后选择了搬瓦工的VPS：512RAM，10G SSD，1000G/月，19.9$/年，用了个优惠码，最后用支付宝付了19刀。</p>\n<p>下面具体介绍下如何创建PPTP VPN:</p>\n<h3 id=\"1-进入搬瓦工控制面板界面\"><a href=\"#1-进入搬瓦工控制面板界面\" class=\"headerlink\" title=\"1.进入搬瓦工控制面板界面\"></a>1.进入搬瓦工控制面板界面</h3><p>点击stop按钮，选择左侧的Install new OS，推荐装Centos 6 x86</p>\n<p><img src=\"http://o6xqhzzif.bkt.clouddn.com/hexo/bandwagon/control_panel.png\" alt=\"img\"></p>\n<h3 id=\"2-安装完毕后可以直接选择Root-shell-interactive启动命令窗口\"><a href=\"#2-安装完毕后可以直接选择Root-shell-interactive启动命令窗口\" class=\"headerlink\" title=\"2.安装完毕后可以直接选择Root shell-interactive启动命令窗口\"></a>2.安装完毕后可以直接选择Root shell-interactive启动命令窗口</h3><p><img src=\"http://o6xqhzzif.bkt.clouddn.com/hexo/bandwagon/shell_window.png\" alt=\"img\"></p>\n<h3 id=\"3-安装一键PPTP-VPN\"><a href=\"#3-安装一键PPTP-VPN\" class=\"headerlink\" title=\"3.安装一键PPTP VPN\"></a>3.安装一键PPTP VPN</h3><p>wget <a href=\"http://www.hi-vps.com/shell/vpn_centos6.sh\">http://www.hi-vps.com/shell/vpn_centos6.sh</a></p>\n<p>sh vpn_centos6.sh</p>\n<p>选择1自动安装VPN，安装完成后，会自动生成一个默认的VPN用户名和随机密码。<br><img src=\"http://o6xqhzzif.bkt.clouddn.com/hexo/bandwagon/install_window.png\" alt=\"img\"></p>\n<h3 id=\"4-添加任意VPN账号\"><a href=\"#4-添加任意VPN账号\" class=\"headerlink\" title=\"4.添加任意VPN账号\"></a>4.添加任意VPN账号</h3><p>sh vpn_centos6.sh</p>\n<p>选择3即可手动添加用户名和密码</p>\n<p><a href=\"http://ckj375.github.io/2016/07/28/%E6%90%AC%E7%93%A6%E5%B7%A5VPS%E6%90%AD%E5%BB%BAPPTP-VPN/\">阅读原文</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"civxk0r7w00007qh77iossje2","category_id":"civxk0r8300027qh7kn6z9py1","_id":"civxk0r8c00087qh78j834vw3"},{"post_id":"civxk0r8100017qh7vrajhwq5","category_id":"civxk0r8a00057qh7pbqjzcmr","_id":"civxk0r8f000c7qh73l2kg5g3"},{"post_id":"civxk0r8700047qh7mu1h4myl","category_id":"civxk0r8d00097qh7y2u0ojgj","_id":"civxk0r8f000e7qh701lh5s4i"},{"post_id":"civxk0r8g000f7qh7bjqgj5iq","category_id":"civxk0r8j000g7qh7k1fwngxx","_id":"civxk0r8k000j7qh7n9ial3zm"},{"post_id":"civxk0r8n000k7qh75qq0y5bc","category_id":"civxk0r8300027qh7kn6z9py1","_id":"civxk0r8v000o7qh74gckw77u"},{"post_id":"civxk0r8o000l7qh72sq8fcuy","category_id":"civxk0r8300027qh7kn6z9py1","_id":"civxk0r8w000q7qh7m6zlr2o5"},{"post_id":"civxk0r8r000n7qh73ha3x9h4","category_id":"civxk0r8w000p7qh721q4vmfd","_id":"civxk0r8y000v7qh7n3i0ue8c"}],"PostTag":[{"post_id":"civxk0r7w00007qh77iossje2","tag_id":"civxk0r8600037qh7c1wqe697","_id":"civxk0r8c00077qh74f4hrdd6"},{"post_id":"civxk0r8100017qh7vrajhwq5","tag_id":"civxk0r8a00067qh708dln6wl","_id":"civxk0r8f000b7qh72ga65h45"},{"post_id":"civxk0r8700047qh7mu1h4myl","tag_id":"civxk0r8d000a7qh7shb24i3e","_id":"civxk0r8f000d7qh7zj8ajsqv"},{"post_id":"civxk0r8g000f7qh7bjqgj5iq","tag_id":"civxk0r8j000h7qh7raadqmlq","_id":"civxk0r8k000i7qh76h51jn4o"},{"post_id":"civxk0r8n000k7qh75qq0y5bc","tag_id":"civxk0r8r000m7qh75vp58ezd","_id":"civxk0r8y000s7qh7nsc0dv7g"},{"post_id":"civxk0r8o000l7qh72sq8fcuy","tag_id":"civxk0r8w000r7qh7t63r5190","_id":"civxk0r8y000u7qh72sfl5nub"},{"post_id":"civxk0r8r000n7qh73ha3x9h4","tag_id":"civxk0r8y000t7qh7xmnafhpw","_id":"civxk0r8z000w7qh7623zhi8k"}],"Tag":[{"name":"内存泄露","_id":"civxk0r8600037qh7c1wqe697"},{"name":"Zsh","_id":"civxk0r8a00067qh708dln6wl"},{"name":"Android Studio","_id":"civxk0r8d000a7qh7shb24i3e"},{"name":"Hexo","_id":"civxk0r8j000h7qh7raadqmlq"},{"name":"Android签名","_id":"civxk0r8r000m7qh75vp58ezd"},{"name":"贴图","_id":"civxk0r8w000r7qh7t63r5190"},{"name":"VPN","_id":"civxk0r8y000t7qh7xmnafhpw"}]}}